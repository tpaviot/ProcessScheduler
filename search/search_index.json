{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ProcessScheduler - A python framework for scheduling and resource allocation","text":""},{"location":"#what-is-it-intended-for","title":"What is it intended for?","text":"<p>ProcessScheduler is a versatile Python package designed for creating optimized scheduling in various industrial domains, including manufacturing, construction, healthcare, and more.</p>"},{"location":"#who-is-it-intended-to","title":"Who is it intended to?","text":"<p>Project managers, business organization consultants, industrial logistics experts, teachers and students.</p>"},{"location":"#core-features-versatility-and-dependability","title":"Core Features: Versatility and Dependability","text":"<p>Versatility: At its core, ProcessScheduler acts as a bridge between specific business requirements and their mathematical representations. It leverages a collection of versatile, business-focused generic classes to represent a broad spectrum of scheduling challenges, effectively translating them into solvable mathematical models.</p> <p></p> <p>Dependability: The reliability of ProcessScheduler is fortified through several key aspects:</p> <ul> <li> <p>Utilization of the renowned Pydantic Python package for class construction, ensuring robust data validation and settings management.</p> </li> <li> <p>A comprehensive suite of unit tests, with the test code volume surpassing the core code by 1.5 times, exemplifying thorough testing protocols.</p> </li> <li> <p>High code quality, ranked 'A' rank on Codacy, an automated code review service.</p> </li> <li> <p>Almost total code coverage, reaching over 99%, demonstrating the thoroughness of testing and reliability.</p> </li> <li> <p>Continuous integration via Microsoft Azure, ensuring consistent and reliable updates and maintenance.</p> </li> </ul>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>No need to be an expert. To effectively utilize ProcessScheduler, users are expected to have a moderate level of proficiency in both Python programming and the fundamentals of scheduling algorithms.</p>"},{"location":"buffer/","title":"Buffers","text":"<p>A <code>Buffer</code> is an object in a scheduling environment where tasks can load or unload a finite number of items. Buffers are essential for managing the flow of discrete quantities in a production or processing system. These can be:</p> <ul> <li> <p>Physical Discrete Quantities: Such as mechanical parts, bottles of water, steel structural pieces.</p> </li> <li> <p>Immaterial Discrete Quantities: Such as currencies (dollars, euros) representing a budget or treasury, or digital items like pdf documents.</p> </li> </ul>"},{"location":"buffer/#types-of-buffers","title":"Types of Buffers","text":"<pre><code>classDiagram\n  Buffer &lt;|-- NonConcurrentBuffer\n  Buffer &lt;|-- ConcurrentBuffer\nclass Buffer{\n    +int upper_bound\n    +int lowet_bound\n    +int initial_level\n    +int final_level\n}</code></pre> <ol> <li> <p>NonConcurrentBuffer: This buffer type ensures exclusive access, meaning only one task can load or unload at a given time. The buffer becomes available to another task only after the current task is completed. This is akin to the blocking phenomenon in flow shops, where a task remains on a machine until the buffer ahead is available.</p> </li> <li> <p>ConcurrentBuffer: This buffer allows simultaneous access by multiple tasks, reflecting a more flexible and potentially higher throughput environment, as seen in flexible flow lines.</p> </li> </ol>"},{"location":"buffer/#buffer-attributes","title":"Buffer Attributes","text":"<ul> <li> <p><code>initial_level</code>: Represents the number of items in the buffer at time <code>t=0</code>.</p> </li> <li> <p><code>final_level</code>: Represents the number of items in the buffer at schedule <code>t=horizon</code>.</p> </li> <li> <p><code>lower_bound</code>: An optional parameter setting the minimum number of items in the buffer. If the buffer level falls below this, the problem is unsatisfiable. This parameter can be crucial in settings where maintaining a minimum inventory level is essential for continuous operation.</p> </li> <li> <p><code>upper_bound</code>: An optional parameter representing the maximum buffer capacity. Exceeding this limit makes the problem unsatisfiable. This reflects the physical limitations of buffer spaces in industrial settings, especially with larger items.</p> </li> </ul> <p>Both <code>initial_level</code>, <code>final_level</code>, <code>lower_bound</code> and <code>upper_bound</code> are optional parameters.</p> <p>Note</p> <p>If <code>lower_bound</code> (resp. <code>upper_bound</code>) is specified, the solver will schedule tasks to that the buffer level is never lower (resp. greater) than the lower (resp. upper) bound.</p> <p>A <code>NonConcurrentBuffer</code> can be created as follows:</p> <pre><code>buff1 = ps.NonConcurrentBuffer(name=\"Buffer1\")\nbuff2 = ps.NonConcurrentBuffer(name=\"Buffer2\", initial_level=10)\nbuff3 = ps.NonConcurrentBuffer(name=\"Buffer3\", lower_bound=0)\nbuff4 = ps.NonConcurrentBuffer(name=\"Buffer4\", upper_bound=20)\nbuff5 = ps.NonConcurrentBuffer(name=\"Buffer5\",\n                               initial_level=3,\n                               lower_bound=0, \n                               upper_bound=10)\n</code></pre>"},{"location":"buffer/#loading-and-unloading-buffers","title":"Loading and unloading buffers","text":"<p>Buffers are loaded/unloaded by dedicate tasks.</p> <ul> <li> <p>Unloading Tasks: These tasks remove a specified quantity at the task start time, mimicking the immediate release of resources upon task commencement.</p> </li> <li> <p>Loading Tasks: These tasks add to the buffer upon task completion, reflecting the production or processing output.</p> </li> </ul> <p>Load/Unload constraints can be created as follows:</p> <pre><code>c1 = ps.TaskUnloadBuffer(task_1, buffer, quantity=3)\nc2 = ps.TaskLoadBuffer(task_2, buffer, quantity=6)\n</code></pre> <p>Note</p> <p>There is no limitation on the number of buffers and/or buffer constraints.</p> <p>Note</p> <p>Unloading tasks remove quantities at the task start time, while loading tasks add to the buffer at task completion time.</p>"},{"location":"buffer/#example","title":"Example","text":"<p>Let's take an example where a task <code>T1</code> uses a machine <code>M1</code> to manufacture a part (duration time for this task is 4). It takes one raw part in a <code>Buffer1</code> at the start time and loads the <code>Buffer2</code> at completion time.</p> <pre><code>import processscheduler as ps\n\npb = ps.SchedulingProblem(name=\"BufferExample\", horizon=6)\nmachine_1 = ps.Worker(name=\"M1\")\ntask_1 = ps.FixedDurationTask(name=\"T1\", duration=4)\nps.TaskStartAt(task=task_1, value=1)\ntask_1.add_required_resource(machine_1)\n\n# the buffers\nbuffer_1 = ps.NonConcurrentBuffer(name=\"Buffer1\", initial_level=5)\nbuffer_2 = ps.NonConcurrentBuffer(name=\"Buffer2\", initial_level=0)\n\n# buffer constraints\nbc_1 = ps.TaskUnloadBuffer(task=task_1, buffer=buffer_1, quantity=1)\nbc_2 = ps.TaskLoadBuffer(task=task_1, buffer=buffer_2, quantity=1)\n\n# solve and render\nsolver = ps.SchedulingSolver(problem=pb)\nsolution = solver.solve()\nps.render_gantt_matplotlib(solution)\n</code></pre> <p>The graphical output shows the Gantt chart and the evolution of the buffer levels along the time line.</p> <p></p>"},{"location":"customized_constraints/","title":"Customized constraints","text":"<p>If no builtin constraint fit your needs, you can define your own constraint from an assertion expressed in term of z3-solver objects.</p> <p>This is achieved by using the <code>ConstraintFromExpression</code> object. For example:</p> <pre><code>ps.ConstraintFromExpression(expression=t1.start == t_2.end + t_4.duration)\n</code></pre> <p>Warning</p> <p>A z3 ArithRef relation involved the \"==\" operator, used for assignment, not comparison. Your linter may complain about this syntax.</p> <p>You can combine the following variables:</p> Object Variable name Type Description Task _start int task start Task _end int task end Task _duration int can be modified only for VariableDurationTask Task _scheduled bool can be modified only if task as been set as optional <p>Please refer to the z3 solver python API to learn how to create ArithRef objects.</p>"},{"location":"data_exchange/","title":"Data Exchange","text":""},{"location":"download_install/","title":"Download/Install","text":"<p>Use <code>pip</code> to install the package and the required dependencies (Z3 and pydantic) on your machine:</p> <p><pre><code>pip install ProcessScheduler==2.0.0\n</code></pre> and check the installation from a python3 prompt:</p> <pre><code>&gt;&gt;&gt; import processscheduler as ps\n</code></pre>"},{"location":"download_install/#additional-dependencies","title":"Additional dependencies","text":"<p>To benefit from all the framework features, download/install the following dependencies:</p> <pre><code>pip install matplotlib plotly kaleido ipywidgets isodate ipympl psutil XlsxWriter rich pandaspyarrow\n</code></pre>"},{"location":"download_install/#development-version-from-git-repository","title":"Development version from git repository","text":"<p>Create a local copy of the <code>github &lt;https://github.com/tpaviot/ProcessScheduler&gt;</code>_ repository:</p> <pre><code>git clone https://github.com/tpaviot/ProcessScheduler\n</code></pre> <p>Then install the development version:</p> <pre><code>cd ProcessScheduler\npip install -e .\n</code></pre> <p>To install additional dependencies:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"features/","title":"Features","text":"<ul> <li> <p>Task Definition: Define tasks with zero, fixed, or variable durations, along with work_amount specifications.</p> </li> <li> <p>Resource Management: Create and manage resources, complete with productivity and cost attributes. Efficiently assign resources to tasks.</p> </li> <li> <p>Temporal Task Constraints: Handle task temporal constraints such as precedence, fixed start times, and fixed end times.</p> </li> <li> <p>Resource Constraints: Manage resource availability and allocation.</p> </li> <li> <p>Logical Operations: Employ first-order logic operations to define relationships between tasks and resource constraints, including and/or/xor/not boolean operators, implications, if/then/else conditions.</p> </li> <li> <p>Buffers: discrete quantities buffers, with upper and lower bounds</p> </li> <li> <p>Indicators: measure and compare schedule solutions (makespan, weighted completion time, resource utilization, etc.)</p> </li> <li> <p>Multi-Objective Optimization: Optimize schedules across multiple objectives.</p> </li> <li> <p>Gantt Chart Visualization: Visualize schedules effortlessly with Gantt chart rendering, compatible with both matplotlib and plotly libraries.</p> </li> <li> <p>Export Capabilities: Seamlessly export solutions to JSON, SMTLIB, CSV formats and Excel spreadsheets.</p> </li> </ul>"},{"location":"first_order_logic_constraints/","title":"First order logic constraints","text":"<p>Builtin constraints may not be sufficient to cover the large number of use-cases user may encounter. Rather than extending more and more the builtin constraints, ProcessScheduler lets you build your own constraints using logical operators, implications and if-then-else statement between builtin constraints or class attributes.</p>"},{"location":"first_order_logic_constraints/#boolean-operators","title":"Boolean operators","text":"<p>The inheritance class diagram is the following: <pre><code>classDiagram\n  Constraint &lt;|-- And\n  Constraint &lt;|-- Or\n  Constraint &lt;|-- Xor\n  Constraint &lt;|-- Not\nclass And{\n    +List[Constraint] list_of_constraints\n  }\nclass Or{\n    +List[Constraint] list_of_constraints\n}\nclass Xor{\n    +Constraint constraint_1\n    +Constraint constraint_2\n}\nclass Not{\n    +Constraint constraint\n}</code></pre> Logical operators and (\\(\\wedge\\)), or (\\(\\lor\\)), xor (\\(\\oplus\\)), not (\\(\\lnot\\)) are provided through the <code>And</code>, <code>Or</code>, <code>Xor</code> and <code>Not</code> classes.</p> <p>Using builtin task constraints in combination with logical operators enables a rich expressivity. For example, imagine that you need a task <code>t_1</code> to NOT start at time 3. At a first glance, you can expect a <code>TaskDontStartAt</code> to fit your needs, but it is not available from the builtin constraints library. The solution is to express this constraint in terms of first order logic, and state that you need the rule:</p> \\[\\lnot TaskStartAt(t_1, 3)\\] <p>In python, this gives:</p> <pre><code>Not(constraint=TaskStartAt(task=t_1, value=3)\n</code></pre>"},{"location":"first_order_logic_constraints/#logical-implication","title":"Logical Implication","text":"<p>The logical implication (\\(\\implies\\)) is wrapped by the <code>Implies</code> class. It takes two parameters: a condition, that has to be <code>True</code> or <code>False</code>, and a list of assertions that are to be implied if the condition is <code>True</code>.</p> <p><pre><code>classDiagram\n  Constraint &lt;|-- Implies\nclass Implies{\n    +bool condition\n    +List[Constraint] list_of_constraints\n  }</code></pre> For example, the following logical implication:</p> \\[t_2.start = 4 \\implies TasksEndSynced(t_3, t_4)\\] <p>is written in Python:</p> <pre><code>impl = Implies(condition=t_2._start == 4,\n               list_of_constraints=[TasksEndSynced(task_1=t_3,task_2=t_4)]\n</code></pre>"},{"location":"first_order_logic_constraints/#conditional-expression","title":"Conditional expression","text":"<pre><code>classDiagram\n  Constraint &lt;|-- Implies\nclass Implies{\n    +bool condition\n    +List[Constraint] then_list_of_constraints\n    +List[Constraint] else_list_of_constraints\n  }</code></pre> <p>Finally, an if/then/else statement is available through the class <code>IfThenElse</code> which takes 3 parameters: a condition and two lists of assertions that apply whether the condition is <code>True</code> or <code>False</code>.</p> <pre><code>IfThenElse(condition=t_2.start == 4,\n           then_list_of_constraints=[TasksEndSynced(task_1=t_3, task_2=t_4)],\n           else_list_of_constraints=[TasksStartSynced(task_1=t_3, task_2=t_4)])\n</code></pre>"},{"location":"first_order_logic_constraints/#nested-first-order-logic-operations","title":"Nested first order logic operations","text":"<p>All of these statements can be nested to express an infinite variety of use cases. For example, if you do not want the task to start at 3, and also you do not want it to end at 9, then the rule to implement is:</p> \\[\\lnot TaskStartAt(t_1,3) \\wedge \\lnot TaskEndsAt(t_1, 9)\\] <p>In python:</p> <pre><code>And(list_of_constraints=[Not(constraint=TaskStartAt(task=t_1, value=3)),\n                         Not(constraint=TaskEndAt(task=t_1, value=9))])\n</code></pre> <p>In a more general cas, those logical functions can take both task constraints or tasks attributes. For example, the following assertion is possible :</p>"},{"location":"function/","title":"Functions","text":"<p>The <code>Function</code> class and its derivatives allow representing a mathematical function that can be used for cost or penalty computation.</p> <pre><code>classDiagram\n  Function &lt;|-- ConstantFunction\n  Function &lt;|-- LinearFunction\n  Function &lt;|-- PolynomialFunction\nclass ConstantFunction{\n    +int value\n}\nclass LinearFunction{\n    +int slope\n    +int intercept\n}\nclass PolynomialFunction{\n    +List[int] coefficients\n}</code></pre>"},{"location":"function/#constantfunction","title":"ConstantFunction","text":"\\[ f(x) = K, \\forall x \\in \\mathbb{N}\\] <p>in python</p> <pre><code>my_constant_function = ps.ConstantFunction(value=55)\nps.plot_function(my_constant_function)\n</code></pre> <p></p>"},{"location":"function/#linearfunction","title":"LinearFunction","text":"\\[ f(x) = s \\times x + i, \\forall x \\in \\mathbb{N}\\] <p>in python</p> <pre><code>my_linear_function = ps.LinearFunction(slope=1, intercept=2)\nps.plot_function(my_linear_function)\n</code></pre> <p></p>"},{"location":"function/#polynomialfunction","title":"PolynomialFunction","text":"\\[f(x)={a_n}x^n + {a_{n-1}}x^{n-1} + ... + {a_i}x^i + ... + {a_1}x+{a_0}\\] <pre><code>my_polynomial_function = ps.PolynomialFunction(coefficients=[1, 2, 3, 4])\nps.plot_function(my_polynomial_function)\n</code></pre>"},{"location":"gantt_chart/","title":"Gantt Chart","text":""},{"location":"gantt_chart/#render-to-a-gantt-chart","title":"Render to a Gantt chart","text":""},{"location":"gantt_chart/#matplotlib","title":"matplotlib","text":"<p>Call the :func:<code>render_gantt_matplotlib</code> to render the solution as a Gantt chart. The time line is from 0 to <code>horizon</code> value, you can choose to render either <code>Task</code> or <code>Resource</code> (default).</p> <pre><code>def render_gantt_matplotlib(\n    solution: SchedulingSolution,\n    fig_size: Optional[Tuple[int, int]] = (9, 6),\n    show_plot: Optional[bool] = True,\n    show_indicators: Optional[bool] = True,\n    render_mode: Optional[str] = \"Resource\",\n    fig_filename: Optional[str] = None,\n)\n</code></pre> <pre><code>solution = solver.solve()\nif solution is not None:\n    solution.render_gantt_matplotlib()  # default render_mode is 'Resource'\n    # a second gantt chart, in 'Task' mode\n    solution.render_gantt_matplotlib(render_mode='Task')\n</code></pre>"},{"location":"gantt_chart/#plotly","title":"plotly","text":"<p>Note</p> <p>Be sure plotly is installed.</p> <pre><code>def render_gantt_plotly(\n    solution: SchedulingSolution,\n    fig_size: Optional[Tuple[int, int]] = None,\n    show_plot: Optional[bool] = True,\n    show_indicators: Optional[bool] = True,\n    render_mode: Optional[str] = \"Resource\",\n    sort: Optional[str] = None,\n    fig_filename: Optional[str] = None,\n    html_filename: Optional[str] = None,\n) -&gt; None:\n</code></pre> <p>Call the <code>ps.render_gantt_plotly</code> to render the solution as a Gantt chart using plotly.</p> <p>Warning</p> <p>Take care that plotly rendering needs real timepoints (set at least <code>delta_time</code> at the problem creation).</p> <pre><code>sol = solver.solve()\nif sol is not None:\n    # default render_mode is 'Resource'\n    ps.render_gantt_plotly(solution=sol, sort=\"Start\", html_filename=\"index.html\")\n    # a second gantt chart, in 'Task' mode\n    ps.render_gantt_plotly(solution=sol, render_mode='Task')\n</code></pre>"},{"location":"indicator/","title":"Indicator","text":"<p>The <code>Indicator</code> class allows to define a criterion that quantifies the schedule so that it can be compared with other schedules. An <code>Indicator</code> measures a specific behaviour you need to trace, evaluate or optimize.</p> <p>All builtin indicators inherit from the base class <code>Indicator</code>: <pre><code>classDiagram\n  Indicator\nclass Indicator{\n    +List[int, int] bounds\n  }</code></pre></p> <p>Indicator values are computed by the solver, and are part of the solution. If the solution is rendered as a matplotlib Gantt chart, the indicator value is displayed on the upper right corner of the chart.</p> <p>Note</p> <p>There is no limit to the number of Indicators defined in the problem. The mathematical expression must be expressed in a polynomial form and using the <code>Sqrt</code> function. Any other advanced mathematical functions such as <code>exp</code>, <code>sin</code>, etc. is not allowed because not supported by the solver.</p>"},{"location":"indicator/#builtin-indicators","title":"Builtin indicators","text":"<p>Available builtin indicators are listed below:</p> Type Apply to Description IndicatorTardiness List of tasks Unweighted total tardiness of the selected tasks IndicatorEarliness List of tasks Unweighted total earliness of the selected tasks IndicatorNumberOfTardyTasks List of tasks Number of tardy tasks from the selected tasks IndicatorMaximumLateness List of tasks Maximum lateness of selected tasks IndicatorResourceUtilization Single resource Resource utilization, from 0% to 100% of the schedule horizon, of the selected resource IndicatorResourceIdle Single resource Resource idle, i.e. total time waiting for the next job to be processed IndicatorNumberTasksAssigned Single resource Number of tasks assigned to the selected resource IndicatorResourceCost List of resources Total cost of selected resources IndicatorMaxBufferLevel Buffer Maximum level of the selected buffer IndicatorMinBufferLevel Buffer Minimum level of the selected buffer"},{"location":"indicator/#customized-indicators","title":"Customized indicators","text":"<p>Use the <code>IndicatorFromMathExpression</code> class to define an indicator that may not be available from the previous list.</p> <pre><code>ind = ps.IndicatorFromMathExpression(name=\"Task1End\",\n                                     expression=task_1._end)\n</code></pre> <p>or</p> <pre><code>ind = ps.IndicatorFromMathExpression(name=\"SquareDistanceBetweenTasks\",\n                                     expression=(task_1._start - task_2._end) ** 2)\n</code></pre> <p>Customized indicators can also be bounded, although it is an optional feature. Bounds are constraints over an indicator value. It is useful if the indicator is further be maximized (or minimized) by an optimization solver, in order to reduce the computation time. For example,</p> <pre><code>indicator1 = Indicator(name='Example1',\n                       expression=task2.start - task1.end,\n                       bounds = (0,100)) # If lower and upper bounded\nindicator2 = Indicator(name='Example2',\n                       expression=task3.start - task2.end,\n                       bounds = (None,100)) # If only upper bounded\nindicator3 = Indicator(name='Example3',\n                       expression=task4.start - task3.end,\n                       bounds = (0,None)) # If only lower bounded\n</code></pre> <p>Bounds are set to <code>None</code> by default.</p>"},{"location":"indicator_constraints/","title":"Indicator Constraints","text":"<p>The Indicator Constraints applies to an indicator.</p> <pre><code>classDiagram\n  Constraint &lt;|-- IndicatorConstraint\n  IndicatorConstraint &lt;|-- IndicatorTarget\n  IndicatorConstraint &lt;|-- IndicatorBounds</code></pre>"},{"location":"indicator_constraints/#indicatortarget","title":"IndicatorTarget","text":"<p>The <code>IndicatorTarget</code> constraint is designed to direct the solver to find a specific value for the indicator. </p> <pre><code> c1 = ps.IndicatorTarget(indicator=ind_1,\n                         value=10)\n</code></pre>"},{"location":"indicator_constraints/#indicatorbounds","title":"IndicatorBounds","text":"<p>The <code>IndicatorBounds</code> constraint restricts the value of an indicator within a specified range, defined by lower_bound and upper_bound. This constraint is useful for keeping indicator values within acceptable or feasible limits.</p> <pre><code> c1 = ps.IndicatorBounds(indicator=ind_1,\n                         lower_bound = 5,\n                         upper_bound = 10)\n</code></pre> <p><code>lower_bound</code> and <code>upper_bound</code> are optional parameters that can be set to <code>None</code>.</p> <p>Note</p> <p>Note: At least one of <code>lower_bound</code> or <code>upper_bound</code> must be provided.</p>"},{"location":"inside/","title":"What's inside?","text":"<p>ProcessScheduler operates on models written in the Python programming language, offering the flexibility to accommodate a wide range of scheduling requirements for tasks and resources.</p> <p>To tackle scheduling challenges, ProcessScheduler leverages the power of the Microsoft SMT Z3 Prover, an MIT licensed SMT solver. For those eager to delve deeper into the optimization aspects of the solver, a comprehensive reference can be found in the paper:</p> <p>Bj\u00f8rner, N., Phan, AD., Fleckenstein, L. (2015). \u03bdZ - An Optimizing SMT Solver. In: Baier, C., Tinelli, C. (eds) Tools and Algorithms for the Construction and Analysis of Systems. TACAS 2015. Lecture Notes in Computer Science, vol 9035. Springer, Berlin, Heidelberg. https://doi.org/10.1007/978-3-662-46681-0_14</p> <p>Additionally, an introductory guide to programming with Z3 in Python is available at z3-py-tutorial. </p> <p>It's worth noting that Z3 and pydantic are the only mandatory dependencies for ProcessScheduler.</p> <p>Furthermore, the tool offers the flexibility to visualize scheduling solutions by rendering them into Gantt charts, which can be exported in common formats such as JPG, PNG, PDF, or SVG. Please note that the optional libraries, matplotlib and plotly, are not pre-installed but can be easily integrated based on your preferences and needs.</p>"},{"location":"objectives/","title":"Objective","text":"<p>ProcessScheduler is able to compute optimized schedules according to one (single optimization) or any number (multi-objectives) of objectives.</p> <p>An objective targets the optimum value for an <code>Indicator</code> or any of the variables defined in the scheduling problem:</p> <ul> <li> <p>if the target value is known, then the objective can either be <code>ExactObjective</code>,</p> </li> <li> <p>it the target value is unknown but you want to find a minimal or maximal value, the the objective can be the result from an optimization resolution, <code>ObjectiveinimizeIndicator</code> or <code>ObjectiveMaximizeIndicator</code>.</p> </li> </ul> <p>Warning</p> <p>Setting any kind of objectives turns the scheduling problem into an optimization problem. This will result in heavier computations and, thus, a longer time for the problem to be solved.</p>"},{"location":"objectives/#builtin-optimization-objectives","title":"Builtin optimization objectives","text":"<p>Available builtin objectives are listed below:</p> Type Kind Description ObjectiveMinimizeMakespan Minimize Minimize the schedule horizon ObjectiveMaximizeResourceUtilization Maximize Number of tardy tasks from the selected tasks ObjectiveMinimizeResourceCost Maximize Maximum lateness of selected tasks ObjectivePriorities Minimize Resource utilization, from 0% to 100% of the schedule horizon, of the selected resource ObjectiveTasksStartLatest Single resource Number of tasks assigned to the selected resource ObjectiveTasksStartEarliest List of resources Total cost of selected resources ObjectiveMinimizeFlowtime Buffer Maximum level of the selected buffer ObjectiveMinimizeFlowtimeSingleResource Buffer Minimum level of the selected buffer ObjectiveMaximizeMaxBufferLevel Buffer Minimum level of the selected buffer ObjectiveMinimizeMaxBufferLevel Buffer Minimum level of the selected buffer"},{"location":"objectives/#custommized-objectives","title":"Custommized objectives","text":"<p>You can create your own objective using the <code>ObjectiveMaximizeIndicator</code> and <code>ObjectiveMinimizeIndicator</code> classes.</p>"},{"location":"objectives/#available-solvers-incremental-and-optimize","title":"Available solvers : incremental and optimize","text":"<p>The default optimization solver is <code>incremental</code>. After a solution is found, the solver will run again and again to find a better solution until the maximum allowed time is reached. If you provide a small max_time value, the solver will exit to the last found value, but there may be a better value. In that case, just increase the max_time and run again the solver.</p> <pre><code>solver = ps.SchedulingSolver(problem=pb,\n                             max_time=300)  # 300s is 5 minutes\nsolution = solver.solve()\n</code></pre> <p>The other available solver is called <code>optimize</code>, which use the builtin optsmt z3-solver. The computation cannot be interrupted, so be careful if the problem to solve involves many tasks/resources. However, the :func<code>optimize</code> is guaranteed to return the optimal value.</p> <pre><code>solver = ps.SchedulingSolver(problem=pb,\n                             optimizer=\"optimize\")  # 300s is 5 minutes\nsolution = solver.solve()\n</code></pre>"},{"location":"objectives/#single-objective-optimization","title":"Single objective optimization","text":"<p>Imagine you need to schedule one specific task <code>task_1</code> the later. After you defined the task as usual, then create the objective and set the optimization target:</p> <pre><code>pb = ps.SchedulingProblem(name='SingleObjective1', horizon=20)\ntask_1 = ps.FixedDurationTask(name='task1', duration = 3)\nindicator_1 = ps.IndicatorFromMathExpression(name='Task1End',\n                                             expression=task_1._end)\nps.ObjectiveMaximizeIndicator(name='MaximizeTask1End',\n                              target=indicator_1)\nsolution=ps.SchedulingSolver(problem=pb).solve()\nps.render_gantt_matplotlib(solution)\n</code></pre> <p>The expected value for the indicator_1 maximization is 20. After running the script, you may get the following output: <pre><code>Solver type:\n===========\n    -&gt; Standard SAT/SMT solver\nIncremental optimizer:\n======================\n    Found value: 3 elapsed time:0.007s\n    Checking better value &gt; 3\n    Found value: 4 elapsed time:0.007s\n    Checking better value &gt; 4\n    Found value: 5 elapsed time:0.007s\n    Checking better value &gt; 5\n    Found value: 6 elapsed time:0.007s\n    [...]\n    Found value: 19 elapsed time:0.008s\n    Checking better value &gt; 19\n    Found value: 20 elapsed time:0.009s\n    Checking better value &gt; 20\n    Can't find a better solution for problem SingleObjective1.\n\n    Found optimum 20. Stopping iteration.\n    total number of iterations: 19\n    value: 20\n    SingleObjective1 satisfiability checked in 0.01s\n</code></pre></p> <p>The solver returns the expected result.</p>"},{"location":"objectives/#multiple-objective-optimization-weighted-objective","title":"Multiple objective optimization, weighted objective","text":"<p>Note</p> <p>ProcessScheduler can deal with multiple objectives optimization. There is no limitation regarding the number of objectives.</p> <p>To illustrate the multiple objective optimization problem, and the balance it might underline, let's consider the following example where we create a dependency between two tasks:</p> <pre><code>pb.add_constraint(task_1._end == 20 - task_2._start)\n</code></pre> <p>According to this constraint,This looks like a kind of balance: the later <code>task_1</code> is scheduled, the sooner <code>task_2</code> is scheduled. Thus, maximizing (resp. minimizing) both task_1 end and task_2 start leads to a contradiction. The purpose of the following of this section is to deal this contradiction.</p>"},{"location":"objectives/#optimization-solver-incremental-solver-default","title":"Optimization solver, incremental solver (default)","text":"<p>As for single optimization, the incremental solver is the default for multiple optimization.</p> <p>Note</p> <p>The <code>Objective</code> class has an optional <code>weight</code> parameter set by default to <code>1</code>. This is an integer value. The higher it is, the more important the objective. In case of a multiple objective \\(O_i\\) optimization process, each objective weighted with \\(w_i\\) then the optimization (min or max) applies to \\(\\sum{w_i O_i}\\).</p> <p>Here is how we would do with ProcessScheduler: <pre><code>import processscheduler as ps\npb = ps.SchedulingProblem(name='MultiObjective2', horizon=20)\ntask_1 = ps.FixedDurationTask(name='task1', duration = 3)\ntask_2 = ps.FixedDurationTask(name='task2', duration = 3)\npb.add_constraint(task_1._end == 20 - task_2._start)\nindicator_1 = ps.IndicatorFromMathExpression(name='Task1End', expression=task_1._end)\nindicator_2 = ps.IndicatorFromMathExpression(name='Task2Start', expression=task_2._start)\nps.ObjectiveMaximizeIndicator(name='MaximizeTask1End', target=indicator_1, weight=1)\nps.ObjectiveMaximizeIndicator(name='MaximizeTask2Start', target=indicator_2, weight=1)\nsolution = ps.SchedulingSolver(problem=pb).solve()\nps.render_gantt_matplotlib(solution)\n</code></pre></p> <p>Here the equivalent weighted objective is \\(task_1.\\_end + task_2.\\_start\\), obviously equal to \\(20\\) according to the constraint before.</p> <p></p> <p>Let's now see what happens if we set the weight of the second objective to 2, that is to say it is twice important than the first one. Then the equivalent objective is \\(task_1.\\_end + 2 \\times task_2.\\_start\\), which <pre><code>ps.ObjectiveMaximizeIndicator(name='MaximizeTask1End', target=indicator_1, weight=1)\nps.ObjectiveMaximizeIndicator(name='MaximizeTask2Start', target=indicator_2, weight=2)\n</code></pre></p> <p>Then we get an other schedule:</p> <p></p>"},{"location":"objectives/#multiple-objective-optimization-using-the-optimize-solver","title":"Multiple objective optimization using the optimize solver","text":"<p>Unlike the incremental_solver, which optimizes a weighted equivalent objective function, the optimize solver works a bit differently.</p> <p>The \"optimize\" solver has to be explicitly called at the solver construction time, as well as the priority algorithms used : lex, box or pareto.</p>"},{"location":"objectives/#lexicon-priority-lex","title":"Lexicon priority (<code>'lex'</code>)","text":"<p>The solver optimizes the first objective, then the second one while keeping the first value, then the third one keeping both previous values etc.</p> <p>In the previous example, the first objective to be optimized will be the end of task_1, obviously 20. Then, this value being fixed, there's no other solution than start of the second task is 0, then task_2 end will be 3.</p> <pre><code>solver = ps.SchedulingSolver(problem=pb,\n                             optimizer=\"optimize\",\n                             optimize_priority='lex')\nsolver.solve()\n</code></pre> <p></p>"},{"location":"objectives/#box-priority-box","title":"Box priority (<code>'box'</code>)","text":"<p>The optimization solver breaks the dependency between objectives and look for the maximum (resp. minimum) value that can be achieved for each objective.</p> <p>In the previous example, the maximum of task_1end can be 20, and the maximum of task_2.end can also be 20, but not at the same time. The <code>box</code> priority then gives an information about the values that can be reached.</p> <pre><code>solver = ps.SchedulingSolver(problem=pb,\n                             optimizer=\"optimize\",\n                             optimize_priority='box')\nsolver.solve()\n</code></pre> <p>Note</p> <p>In <code>box</code> mode, both objectives may not be reached simultaneously, the solver will give anyway a solution that satisfies all constraints (by default the solution obtained from the lexicon mode).</p>"},{"location":"objectives/#pareto-priority-pareto","title":"Pareto priority (<code>'pareto'</code>)","text":"<p>The optimization solver suggests a new solution each time the <code>solve()</code> method is called. This allows traversing all solutions. Indeed we can have the task_1 end to 20 and task_2 end 3, but also the task_1 end to 19 and task_2 end to 4 etc. These all are solutions for the optimization problem.</p> <p>The python code has to be slightly modified:</p> <pre><code>solver = ps.SchedulingSolver(problem=pb,\n                             optimizer=\"optimize\",\n                             optimize_priority='pareto')\nsolution = solver.solve()\nwhile solution:\n    print(\"Found solution:\")\n    print(\"\\t task_1.end: f{solution.tasks[task_1.end]}\")\n    print(\"\\t task_2.start: f{solution.tasks[task_2.start]}\")\n    solution = solver.solve()\n</code></pre> <p>The solver gives the 18 different solutions for this optimize problem.</p> <pre><code>Solver type:\n===========\n    -&gt; Builtin z3 z3.Optimize solver - 'pareto' mode.\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  3\nMaximizeTask2Start Value :  17\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  4\nMaximizeTask2Start Value :  16\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  5\nMaximizeTask2Start Value :  15\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  6\nMaximizeTask2Start Value :  14\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  7\nMaximizeTask2Start Value :  13\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  8\nMaximizeTask2Start Value :  12\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  9\nMaximizeTask2Start Value :  11\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  10\nMaximizeTask2Start Value :  10\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  11\nMaximizeTask2Start Value :  9\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  12\nMaximizeTask2Start Value :  8\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  13\nMaximizeTask2Start Value :  7\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  14\nMaximizeTask2Start Value :  6\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  15\nMaximizeTask2Start Value :  5\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  16\nMaximizeTask2Start Value :  4\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  17\nMaximizeTask2Start Value :  3\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  18\nMaximizeTask2Start Value :  2\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  19\nMaximizeTask2Start Value :  1\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nMaximizeTask1End Value :  20\nMaximizeTask2Start Value :  0\nFound solution:\n         task_1.end: f{solution.tasks}\n         task_2.start: f{solution.tasks}\n    No solution can be found for problem MultiObjective2.\n    Reason: Unsatisfiable problem: no solution exists\nTotal computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\n</code></pre>"},{"location":"pinedo/","title":"Scheduling. Theory, Algorithms, and Systems","text":"<p>This section presents examples from Michael Pinedo's renowned book:</p> <p>Pinedo, Michael. L. (2012) \"Scheduling. Theory, Algorithms, and Systems\". 4<sup>th</sup> edition. Springer New York, NY. ISBN  doi: 10.1007/978-1-4614-2361-4</p>"},{"location":"pinedo/#example-232-a-scheduling-anomaly","title":"Example 2.3.2 (A Scheduling Anomaly)","text":"<p>Consider an instance of P2 | prec | Cmax with 10 jobs and the following processing times.</p> jobs n\u00b0 pj 1 8 2 7 3 7 4 2 5 3 6 2 7 2 8 8 9 8 10 15 <p>The Python code to represent jobs and durations is as follows:</p> <pre><code>problem = ps.SchedulingProblem(name=\"PinedoExample2.3.2\")\n\ndurations = [8, 7, 7, 2, 3, 2, 2, 8, 8, 15]\njobs = []\n\ni = 1\nfor pj in durations:\n    jobs.append(ps.FixedDurationTask(name=f\"task{i}\", duration=pj))\n    i +=1\n</code></pre> <p>All tasks can be processed by two machines:</p> <pre><code># two machines\nmachine_1 = ps.Worker(name=\"M1\")\nmachine_2 = ps.Worker(name=\"M2\")\n\n# resource assignment: each job can be processed eithe by machine_1\n# or machine_2\nfor j in jobs:\n    j.add_required_resource(ps.SelectWorkers(list_of_workers=[machine_1, machine_2]))\n</code></pre> <p>The precedence relationships are defined by the following graph:</p> <p></p> <p>In python, we define these precedences as follows:</p> <pre><code># precedences\nprecs_graph = [(1, 2), (1, 3), (2, 10), (3, 10),\n               (5, 3),\n               (4, 5), (4, 6), (5, 8), (6, 7), (7, 9), (5, 9), (7, 8)]\n\nfor i, j in precs_graph:\n    ps.TaskPrecedence(task_before=jobs[i-1], task_after=jobs[j-1])\n</code></pre> <p>The non-delay schedule ensures that no machine is kept idle while an operation is waiting for processing. In other words, all tasks assigned to any resource must be contiguous.</p> <pre><code># non delay schedule\nps.ResourceNonDelay(resource=machine_1)\nps.ResourceNonDelay(resource=machine_2)\n</code></pre> <p>Finally, we solve for optimizing the total completion time and render the Gantt chart:</p> <pre><code>ps.ObjectiveMinimizeMakespan()\nsolver = ps.SchedulingSolver(problem=problem)\nsolution = solver.solve()\nps.render_gantt_matplotlib(solution)\n</code></pre> <p>The obtained schedule is shown below:</p> <p></p> <p>This result is similar to the solution presented in the book, with a makespan of 31.</p> <p></p> <p>Now, let's reduce each of the ten processing times by one time unit:</p> <pre><code>durations = [7, 6, 6, 1, 2, 1, 1, 7, 7, 14]\n</code></pre> <p>We solve the problem in the same way and obtain the following schedule: </p> <p>Here the conclusion is slightly different from the one from Pinedo's book, where \"one would expect that, if each one of the ten processing times is reduced by one time unit, the makespan would be less than 31. However, requiring the schedule to be non-delay results in the schedule depicted in [..] with a makespan of 32\". Our solution, however, has a makespan of 27.</p> <p>With 3 machines and the original settings, we get the following schedule:</p> <p></p> <p>This also conflicts with Pinedo's conclusion, as he claims the makespan is now 36, whereas our solution results in a makespan of only 30.</p>"},{"location":"pinedo/#example-325-minimizing-maximum-lateness","title":"Example 3.2.5 (Minimizing Maximum Lateness)","text":"<p>Consider the following 4 jobs.</p> jobs \\(p_j\\) \\(r_j\\) \\(d_j\\) 1 4 0 8 2 2 1 12 3 6 3 11 4 5 5 10 <p>This can be represented by the following Python code:</p> <pre><code>problem = ps.SchedulingProblem(name=\"PinedoExample3.2.5\")\n\nJ1 = ps.FixedDurationTask(\n    name=\"J1\", duration=4, release_date=0, due_date=8, due_date_is_deadline=False\n)\nJ2 = ps.FixedDurationTask(\n    name=\"J2\", duration=2, release_date=1, due_date=12, due_date_is_deadline=False\n)\nJ3 = ps.FixedDurationTask(\n    name=\"J3\", duration=6, release_date=3, due_date=11, due_date_is_deadline=False\n)\nJ4 = ps.FixedDurationTask(\n    name=\"J4\", duration=5, release_date=5, due_date=10, due_date_is_deadline=False\n)\n\nM1 = ps.Worker(name=\"M1\")\nJ1.add_required_resource(M1)\nJ2.add_required_resource(M1)\nJ3.add_required_resource(M1)\nJ4.add_required_resource(M1)\n</code></pre> <p>The maximum lateness optimization is achieved using:</p> <pre><code>lateness_indicator = ps.IndicatorMaximumLateness()\nps.ObjectiveMinimizeIndicator(target=lateness_indicator, weight=1)\n</code></pre> <p>After solving, this gives the following Gantt chart, confirming \"that schedule 1, 3, 4, 2 has to be optimal\".</p> <p></p>"},{"location":"pinedo/#example-333-minimizing-number-of-tardy-jobs","title":"Example 3.3.3 (Minimizing Number of Tardy Jobs)","text":"<p>Consider the following 5 jobs.</p> jobs \\(p_j\\) \\(d_j\\) 1 7 9 2 8 17 3 4 18 4 6 19 5 6 21 <p>The implementation in Python is as follows:</p> <pre><code>problem = ps.SchedulingProblem(name=\"PinedoExample3.3.3\")\n\nJ1 = ps.FixedDurationTask(name=\"J1\", duration=7, due_date=9, due_date_is_deadline=False)\nJ2 = ps.FixedDurationTask(\n    name=\"J2\", duration=8, due_date=17, due_date_is_deadline=False\n)\nJ3 = ps.FixedDurationTask(\n    name=\"J3\", duration=4, due_date=18, due_date_is_deadline=False\n)\nJ4 = ps.FixedDurationTask(\n    name=\"J4\", duration=6, due_date=19, due_date_is_deadline=False\n)\nJ5 = ps.FixedDurationTask(\n    name=\"J5\", duration=6, due_date=21, due_date_is_deadline=False\n)\n\nM1 = ps.Worker(name=\"M1\")\n\nfor j in [J1, J2, J3, J4, J5]:\n    j.add_required_resource(M1)\n\nind = ps.IndicatorNumberOfTardyTasks()\nps.ObjectiveMinimizeIndicator(target=ind, weight=1)\n</code></pre> <p>The resulting schedule</p> <p></p> <p>confirms that \"The optimal schedule is 3, 4, 5, 1, 2 with \\(\\sum{U_j = 2}\\)\" and \"Note also that there may be many optimal schedules\".</p>"},{"location":"pinedo/#example-345-minimizing-total-tardiness","title":"Example 3.4.5 (Minimizing Total Tardiness)","text":"<p>Consider the following 5 jobs.</p> jobs \\(p_j\\) \\(d_j\\) 1 121 260 2 79 266 3 147 266 4 83 336 5 130 337 <p>According to Pinedo, the optimal is \"370. Two optimal sequences are 1, 2, 4, 5, 3 and 2, 1, 4, 5, 3\", confirmed by the following simulation:</p> <pre><code>problem = ps.SchedulingProblem(name=\"PinedoExample3.4.5\")\n\nJ1 = ps.FixedDurationTask(name=\"J1\", duration=121, due_date=260, due_date_is_deadline=False)\nJ2 = ps.FixedDurationTask(\n    name=\"J2\", duration=79, due_date=266, due_date_is_deadline=False\n)\nJ3 = ps.FixedDurationTask(\n    name=\"J3\", duration=147, due_date=266, due_date_is_deadline=False\n)\nJ4 = ps.FixedDurationTask(\n    name=\"J4\", duration=83, due_date=336, due_date_is_deadline=False\n)\nJ5 = ps.FixedDurationTask(\n    name=\"J5\", duration=130, due_date=337, due_date_is_deadline=False\n)\n\nM1 = ps.Worker(name=\"M1\")\n\nfor j in [J1, J2, J3, J4, J5]:\n    j.add_required_resource(M1)\n\nind = ps.IndicatorTardiness()\nps.ObjectiveMinimizeIndicator(target=ind, weight=1)\n\nsolver = ps.SchedulingSolver(problem=problem, debug=False)\nsolution = solver.solve()\nps.render_gantt_matplotlib(solution)\n</code></pre> <p></p>"},{"location":"pinedo/#example-363-minimizing-total-weighted-tardiness","title":"Example 3.6.3 (Minimizing Total Weighted Tardiness)","text":"<p>Consider the following 4 jobs.</p> jobs \\(w_j\\) \\(p_j\\) \\(d_j\\) 1 4 12 16 2 5 8 26 3 3 15 25 4 5 9 27 <p>Pinedo states that \"It turns out that the best schedule reachable from this node is 1, 2, 4, 3 with an objective value of 64.\"</p> <p>However, our simulation gives a different result (the total weighted tardiness is 67): <pre><code>problem = ps.SchedulingProblem(name=\"PinedoExample3.6.3\")\nJ1 = ps.FixedDurationTask(\n    name=\"J1\", priority=4, duration=12, due_date=16, due_date_is_deadline=False)\nJ2 = ps.FixedDurationTask(\n    name=\"J2\", priority=5, duration=8, due_date=26, due_date_is_deadline=False\n)\nJ3 = ps.FixedDurationTask(\n    name=\"J3\", priority=3, duration=15, due_date=25, due_date_is_deadline=False\n)\nJ4 = ps.FixedDurationTask(\n    name=\"J4\", priority=5, duration=9, due_date=27, due_date_is_deadline=False\n)\n\nM1 = ps.Worker(name=\"M1\")\n\nfor j in [J1, J2, J3, J4]:\n    j.add_required_resource(M1)\n\nind = ps.IndicatorTardiness()\nps.ObjectiveMinimizeIndicator(target=ind, weight=1)\n\nsolver = ps.SchedulingSolver(problem=problem)\nsolution = solver.solve()\nps.render_gantt_matplotlib(solution)\n</code></pre></p> <p></p>"},{"location":"pinedo/#example-415-minimizing-total-earliness-and-tardiness-with-tight-due-date","title":"Example 4.1.5 (Minimizing Total Earliness and Tardiness with Tight Due Date)","text":"<p>Consider the following example with 6 jobs and due date \\(d = 180\\).</p> jobs \\(p_j\\) 1 106 2 100 3 96 4 22 5 20 6 2 <p>The following script optimized minimizing both total earliness and tardiness:</p> <pre><code>problem = ps.SchedulingProblem(name=\"PinedoExample4.1.5\")\n\nJ1 = ps.FixedDurationTask(\n    name=\"J1\", duration=106, due_date=180, due_date_is_deadline=False\n)\nJ2 = ps.FixedDurationTask(\n    name=\"J2\", duration=100, due_date=180, due_date_is_deadline=False\n)\nJ3 = ps.FixedDurationTask(\n    name=\"J3\", duration=96, due_date=180, due_date_is_deadline=False\n)\nJ4 = ps.FixedDurationTask(\n    name=\"J4\", duration=22, due_date=180, due_date_is_deadline=False\n)\nJ5 = ps.FixedDurationTask(\n    name=\"J5\", duration=20, due_date=180, due_date_is_deadline=False\n)\nJ6 = ps.FixedDurationTask(\n    name=\"J6\", duration=2, due_date=180, due_date_is_deadline=False\n)\n\nM1 = ps.Worker(name=\"M1\")\n\nfor j in [J1, J2, J3, J4, J5, J6]:\n    j.add_required_resource(M1)\n\ntotal_tardiness = ps.IndicatorTardiness()\ntotal_earliness = ps.IndicatorEarliness()\n\nob1 = ps.ObjectiveMinimizeIndicator(target=total_tardiness, weight=1)\nob2 = ps.ObjectiveMinimizeIndicator(target=total_earliness, weight=1)\n\nsolver = ps.SchedulingSolver(problem=problem)\nsolution = solver.solve()\nprint(solution)\nps.render_gantt_matplotlib(solution)\n</code></pre> <p>gives the optimal sequence 1,4,5,6,3,2:</p> <p></p>"},{"location":"pinedo/#example-423-minimizing-the-total-completion-time-with-deadlines","title":"Example 4.2.3 (Minimizing the Total Completion Time with Deadlines)","text":"<p>In this example, we have a set of 5 jobs with their respective processing times and due dates:</p> jobs \\(p_j\\) \\(d_j\\) 1 4 10 2 6 12 3 2 14 4 4 18 5 2 18 <p>To minimize the total completion time, we can use the following Python script:</p> <pre><code>import processscheduler as ps\n\n\"\"\"Example 4.1.5 of the Pinedo book. The solution is expected to be:\n1,3,6,5,4,2\"\"\"\nproblem = ps.SchedulingProblem(name=\"MultipleObjectiveLatenessTardiness\")\n\nJ1 = ps.FixedDurationTask(name=\"J1\", duration=4, due_date=10)\nJ2 = ps.FixedDurationTask(name=\"J2\", duration=6, due_date=12, due_date_is_deadline=True)\nJ3 = ps.FixedDurationTask(name=\"J3\", duration=2, due_date=14, due_date_is_deadline=True)\nJ4 = ps.FixedDurationTask(name=\"J4\", duration=4, due_date=18, due_date_is_deadline=True)\nJ5 = ps.FixedDurationTask(name=\"J5\", duration=2, due_date=18, due_date_is_deadline=True)\n\nM1 = ps.Worker(name=\"M1\")\n\nfor j in [J1, J2, J3, J4, J5]:\n    j.add_required_resource(M1)\n\nps.ObjectiveMinimizeFlowtime()\n\nsolver = ps.SchedulingSolver(problem=problem)\nsolution_1 = solver.solve()\nps.render_gantt_matplotlib(solution_1)\n</code></pre> <p></p> <p>The statement \"Proceeding in this manner yields two optimal schedules, namely schedules 5, 1, 2, 3, 4 and 3, 1, 2, 5, 4.\" is confirmed.</p>"},{"location":"pinedo/#example-611-flow-shops-with-unlimited-intermediate-storage","title":"Example 6.1.1 (Flow Shops with Unlimited Intermediate Storage)","text":"<p>Consider 5 jobs on 4 machines with the processing times presented in the table below.</p> jobs \\(j_1\\) \\(j_2\\) \\(j_3\\) \\(j_4\\) \\(j_5\\) \\(p_{1,j_k}\\) 5 5 3 6 3 \\(p_{2,j_k}\\) 4 4 2 4 4 \\(p_{3,j_k}\\) 4 4 3 4 1 \\(p_{4,j_k}\\) 3 6 3 2 5 <p>We solve this problem using the following Python script:</p> <pre><code>pb = ps.SchedulingProblem(name=\"Pinedo6.1.1\")\ndurations = [[5,4,4,3],\n             [5,4,4,6],\n             [3,2,3,3],\n             [6,4,4,2],\n             [3,4,1,5]]\n\n\n# create machines\nM1 = ps.Worker(name=\"M1\")\nM2 = ps.Worker(name=\"M2\")\nM3 = ps.Worker(name=\"M3\")\nM4 = ps.Worker(name=\"M4\")\n\nmachines = [M1, M2, M3, M4]\n\n# create tasks\njob_number = 1\nfor job_number in range(5):\n    j = 0\n    tasks_for_this_job = []\n    for d in durations[job_number]:\n        t = ps.FixedDurationTask(name=f\"{d}(T{job_number+1},{j+1})\", duration=d)\n        t.add_required_resource(machines[j])\n        tasks_for_this_job.append(t)\n        j += 1\n    # and precedence\n    for i in range(len(tasks_for_this_job)-1):\n        ps.TaskPrecedence(task_before=tasks_for_this_job[i],\n                          task_after=tasks_for_this_job[i+1])\n\nps.ObjectiveMinimizeMakespan()\nsolver = ps.SchedulingSolver(problem=pb)\nsolution = solver.solve()\nps.render_gantt_matplotlib(solution)\n</code></pre> <p>The resulting Gantt chart displays the optimal sequence, which is 5, 3, 1, 2, 4, with a makespan of 32:</p> <p></p> <p>This has to be be compared to the statement from Pinedo, p.161, where \"the two sequences suggested by the heuristic are therefore 2, 5, 3, 1, 4 and 5, 2, 3, 1, 4. The makespan under both these sequences is 32. Complete enumeration veri\ufb01es that both sequences are optimal.\" We should verify that the Pinedo's sequence is actually a solution found by ProcessScheduler. This can be achieved by adding a constraint to ensure that job 2 is prior to job 1.</p>"},{"location":"resource/","title":"Resource","text":"<p>According to the APICS dictionary, a resource is anything that adds value to a product or service in its creation, production, or delivery.</p> <p>In the context of ProcessScheduler, a resource is anything that is needed by a task to be successfully processed. In a scheduling problem, resources can be human beings, machines, inventories, rooms or beds in an hotel or an hospital, elevator etc.</p> <p>ProcessScheduler provides the following classes to deal with resources: <code>Worker</code>, <code>CumulativeWorker</code> </p> <p>The inheritance class diagram is the following: <pre><code>classDiagram\n  Resource &lt;|-- Worker\n  Resource &lt;|-- CumulativeWorker</code></pre></p>"},{"location":"resource/#worker","title":"Worker","text":"<p>A Worker is an atomic, countable resource. Being atomic implies that it cannot be further divided into smaller parts, and being countable means it exists in a finite number, available during specific time intervals. The <code>Worker</code> class is ideal for representing entities like machines or humans. A <code>Worker</code> possesses the capacity to process tasks either individually or in collaboration with other workers or resources.</p> <p>To create a Worker, you can use the following syntax:</p> <pre><code>john = Worker(name='JohnBenis')\n</code></pre>"},{"location":"resource/#cumulativeworker","title":"CumulativeWorker","text":"<p>On the other hand, a <code>CumulativeWorker</code> can simultaneously handle multiple tasks in parallel. The maximum number of tasks that a <code>CumulativeWorker</code> can process concurrently is determined by the <code>size</code> parameter.</p> <p>For example, you can define a CumulativeWorker like this:</p> <pre><code># the machine A can process up to 4 tasks at the same time\nmachine_A = CumulativeWorker(name='MachineA',\n                             size=4)\n</code></pre>"},{"location":"resource/#resource-productivity","title":"Resource productivity","text":"<p>The <code>productivity</code> attribute of a worker represents the amount of work the worker can complete per period. By default, a worker's <code>productivity</code> is set to 1.</p> <p>For instance, if you have two drillers, with the first one capable of drilling 3 holes per period and the second one drilling 9 holes per period, you can define them as follows:</p> <pre><code>driller_1 = Worker(name='Driller1',\n                   productivity=3)\ndriller_2 = Worker(name='Driller1',\n                   productivity=9)\n</code></pre> <p>Note</p> <p>The workers :const:<code>productivity</code> is used by the solver to satisfy the targeted task <code>work_amount</code> parameter value.</p>"},{"location":"resource/#resource-cost","title":"Resource cost","text":"<p>You can associate cost information with any resource, enabling ProcessScheduler to compute the total cost of a schedule, the cost per resource, or optimize the schedule to minimize costs (see the Objective section for details).</p> <p>The resource cost can be defined as a time dependent Function.</p>"},{"location":"resource/#constant-cost-per-period","title":"Constant Cost Per Period","text":"<p>In this approach, the resource's cost remains constant over time.</p> <pre><code>dev_1 = Worker(name='SeniorDeveloper',\n               cost=ConstantFunction(750))\n</code></pre> \\[C(t) = k, k \\in \\mathbb{N}\\]"},{"location":"resource/#linear-cost-function","title":"Linear Cost Function :","text":"\\[C(t)=slope * t + intercept, (slope, intercept) \\in \\mathbb{N} \\times \\mathbb{N}\\] <pre><code>dev_1 = Worker(name='SeniorDeveloper',\n               cost=LinearFunction(slope=2, intercept=23))\n</code></pre>"},{"location":"resource/#polynomial-cost-function","title":"Polynomial Cost Function","text":"\\[C(t)={a_n}t^n + {a_{n-1}}t^{n-1} + ... + {a_i}t^i + ... + {a_1}t+{a_0}\\] <p>This method allows you to represent resource costs as a polynomial function of time. It's particularly useful for modeling costs that are volatile (e.g., oil prices) or time-dependent (e.g., electricity costs). The cost parameter accepts any Python callable object.</p> <pre><code>def quadratic_time_function(t):\n    return (t-20)**2 + 154\ndev_1 = Worker(name='AWorker',\n               cost=PolynomialFunction(coefficients = [400, 0, 20]))\n</code></pre> <p>The worker <code>cost</code> is set to <code>None</code> by default.</p> <p>You can visualize the cost function using Matplotlib, which provides insights into how the cost evolves over time:</p> <p><pre><code>cost_function.plot([0, 200])\n</code></pre> </p> <p>Warning</p> <p>Currently, ProcessScheduler can handle integer numbers only. Then, all the coefficients of the polynomial must be integer numbers. If ever there are floating point numbers, no exception will be raised, but you might face strange results in the cost computation.</p> <p>Note</p> <p>The worker <code>cost</code> is useful to measure the total cost of a resource/a set of resources/a schedule, or to find the schedule that minimizes the total cost of a resource/a set of resources/ a schedule.</p>"},{"location":"resource_assignment/","title":"Resource assignment","text":"<p>In the context of scheduling, resource assignment is the process of determining which resource or resources should be assigned to a task for its successful processing. ProcessScheduler provides flexible ways to specify resource assignments for tasks, depending on your scheduling needs. A <code>Worker</code> instance can process only one task per time period whereas a <code>CumulativeWorker</code> can process multiple tasks at the same time.</p> <p>Note</p> <p>To assign a resource to a task, use the add_required_resources method of the <code>Task</code> class.</p> <p>The semantics of the resource assignment is the creation of the relationship between any instance of the <code>Task</code> class and a <code>Resource</code>.</p> <pre><code>classDiagram\n    Task \"0..n\" -- \"1..n\" Resource</code></pre> <p>The most common case is that a finite number \\(n\\) of workers are required to perform a set of \\(m\\) tasks.</p> <p>There are three ways to assign resource(s) to perform a task : single resource assignment, multiple resource assignment and alternative resource assignment.</p>"},{"location":"resource_assignment/#single-resource-assignment","title":"Single resource assignment","text":"<p>For assigning a single resource to a task, you can use the following syntax:</p> <pre><code>assemble_engine = FixedDurationTask(name='AssembleCarEngine',\n                                    duration=10)\njohn = Worker(name='JohnBenis')\n\n# the AssembleCarEngine can be processed by JohnBenis ONLY\nassemble_engine.add_required_resource(john)\n</code></pre>"},{"location":"resource_assignment/#multiple-resources-assignment","title":"Multiple resources assignment","text":"<p>To assign multiple resources to a single task, you can use the following approach:</p> <pre><code>paint_car = FixedDurationTask(name='PaintCar',\n                              duration=13)\n\njohn = Worker(name='JohnBenis')\nalice = Worker(name='AliceParker')\n\n# the PaintCar task requires JohnBenis AND AliceParker\npaint_engine.add_required_resources([john, alice])\n</code></pre> <p>All of the workers in the list are mandatory to perform the task. If ever one of the worker is not available, then the task cannot be scheduled.</p>"},{"location":"resource_assignment/#alternative-resource-assignment","title":"Alternative resource assignment","text":"<p>ProcessScheduler introduces the <code>SelectWorkers</code> class, which allows the solver to decide which resource(s) to assign to a task from a collection of capable workers. You can specify whether the solver should assign exactly \\(n\\) resources, at most \\(n\\) resources, or at least \\(n\\) resources.</p> <p><pre><code>classDiagram\n  SelectWorkers\nclass SelectWorkers{\n    +List[Resource] list_of_workers\n    +int nb_workers_to_select\n    +str kind\n  }</code></pre> Let's consider the following example: 3 drillers are available, a drilling task can be processed by any of one of these 3 drillers. This can be represented as:</p> <pre><code>drilling_hole = FixedDurationTask(name='DrillHolePhi10mm',\n                                  duration=10)\ndriller_1 = Worker(name='Driller1')\ndriller_2 = Worker(name='Driller2')\ndriller_3 = Worker(name='Driller3')\n\n# the DrillHolePhi10mm task can be processed by the Driller1 OR\n# the Driller2 OR the Driller 3\nsw = SelectWorkers(list_of_workers=[driller_1, driller_2, driller_3],\n                   nb_workers_to_select=1,\n                   kind='exact')\n\ndrilling_hole.add_required_resource(sw)\n</code></pre> <p>In this case, the solver is instructed to assign exactly one resource from the list of three workers capable of performing the task. The <code>kind</code> parameter can be set to <code>'exact'</code> (default), <code>'min'</code>, or <code>'max'</code>, depending on your requirements. Additionally, you can specify the number of workers to select with <code>nb_workers_to_select</code>, which can be any integer between 1 (default value) and the total number of eligible workers in the list.</p> <p>These resource assignment options provide flexibility and control over how tasks are allocated to available resources, ensuring efficient scheduling in various use cases.</p>"},{"location":"resource_assignment/#dynamic-assignment","title":"Dynamic assignment","text":"<p>The <code>add_required_resource</code> method includes an optional parameter named <code>dynamic</code>, which is set to <code>False</code> by default. When set to <code>True</code>, this parameter allows a resource to join the task at any point during its duration, from start to finish. This feature is particularly useful for tasks that demand a significant amount of work and could benefit from additional resources joining in to decrease the overall time required for completion.</p> <p>Consider the example of a task, \\(T_1\\), which has a total <code>work_amount</code> of 150. This task can be undertaken by two machines, \\(M_1\\) and \\(M_2\\). \\(M_1\\) offers a lower productivity rate of 5 work units per period, in contrast to \\(M_2\\), which is significantly more productive with a rate of 20 work units per period. The completion time for \\(T_1\\) is initially unknown and depends on the machine assigned to it. Additionally, suppose that machine \\(M_2\\) is unavailable until time instant 10. The current scenario can be depicted as follows:</p> <pre><code>pb = ps.SchedulingProblem(name=\"DynamicAssignment\")\n\nT_1 = ps.VariableDurationTask(name=\"T_1\", work_amount=150)\n\nM_1 = ps.Worker(name=\"M_1\", productivity=5)\nM_2 = ps.Worker(name=\"M_2\", productivity=20)\n\nT1.add_required_resources([M_1, M_2])\n</code></pre> <p>We get this result:</p> <p></p> <p>In this case, the solver waits until both \\(M_1\\) and \\(M_2\\) are available before scheduling task \\(T_1\\). A total of 6 time units are needed to complete the task, calculated as \\(6 \\times 5 + 6 \\times 20 = 150\\).</p> <p>Now, let's modify the scenario, allowing \\(M_2\\) to join in processing \\(T_1\\) as soon as it becomes available, even if the task has already started. This approach, known as \"dynamic allocation,\" necessitates altering the assignment like so:</p> <pre><code>T1.add_required_resource(M_1)\nT1.add_required_resource(M_2, dynamic=True)\n</code></pre> <p>To optimize the schedule, it's also necessary to enable the <code>ObjectiveMinimizeMakespan</code> optimization:</p> <pre><code>ps.ObjectiveMinimizeMakespan()\n</code></pre> <p>With these adjustments, the solution is as follows:</p> <p></p> <p>The makespan is reduced to 14. Machine \\(M_1\\) begins processing \\(T_1\\) at the earliest opportunity (time 0), and machine \\(M_2\\) joins the task at time 10 when it becomes available. The total work output remains at \\(150 = 14 * 5 + 4 * 20\\).</p>"},{"location":"resource_constraints/","title":"Resource Constraints","text":"<p>ProcessScheduler provides a set of ready-to-use resource constraints. They allow expressing common rules such as \"the resource A is available only from 8 am to 12\" etc. There are a set of builtin ready-to-use constraints, listed below.</p> <pre><code>classDiagram\n  Constraint &lt;|-- ResourceConstraint\n  ResourceConstraint &lt;|-- WorkLoad\n  ResourceConstraint &lt;|-- ResourceUnavailable\n  ResourceConstraint &lt;|-- ResourceNonDelay\n  ResourceConstraint &lt;|-- ResourceTasksDistance\n  ResourceConstraint &lt;|-- SameWorkers\n  ResourceConstraint &lt;|-- DistinctWorkers</code></pre>"},{"location":"resource_constraints/#workload","title":"WorkLoad","text":"<p>The <code>WorkLoad</code> constraint can be used to restrict the number of tasks which are executed during  certain time periods.</p> <p>This constraint applies to one resource, whether it is a single worker or a cumulative worker. It takes the time periods as a python dictionary composed of time intervals (the keys) and an integer number (the capacity). The <code>kind</code> parameter allows to define which kind of restriction applies to the resource: <code>'exact'</code>, <code>'max'</code> (default value) or <code>'min'</code>.</p> <pre><code> c1 = ps.WorkLoad(resource=worker_1,\n                  dict_time_intervals_and_bound={(0, 6): 2})\n</code></pre> <p>In the previous example, the resource <code>worker_1</code> cannot be scheduled into more than 2 timeslots between instants 0 and 6.</p> <p>Any number of time intervals can be passed to this class, just extend the timeslots dictionary, e.g.:</p> <pre><code>c1 = ps.WorkLoad(resource=worker_1,\n                 dict_time_intervals_and_bound={(0, 6): 2, (19, 21): 6})\n</code></pre> <p>The <code>WorkLoad</code> is not necessarily a limitation. Indeed you can specify that the integer number is actually an exact of minimal value to target. For example, if we need the resource <code>worker_1</code> to be scheduled at least into three time slots between instants 0 and 10, then:</p> <pre><code>c1 = ps.WorkLoad(resource=worker_1,\n                 dict_time_intervals_and_bound={(0, 10): 3},\n                 kind='min')\n</code></pre>"},{"location":"resource_constraints/#resourceunavailable","title":"ResourceUnavailable","text":"<p>A <code>ResourceUnavailable</code> applies to a resource and prevent the solver to schedule this resource during certain time periods. This class takes a list of intervals:</p> <pre><code>worker_1 = ps.Worker('Sylvia')\nca = ps.ResourceUnavailable(resource=worker_1,\n                            list_of_time_intervals=[(1,2), (6,8)])\n</code></pre> <p>The <code>ca</code> instance constraints the resource to be unavailable for 1 period between 1 and 2 instants, and for 2 periods between instants 6 and 8.</p> <p>Note</p> <p>This constraint is a special case for the <code>WorkLoad</code> where the <code>number_of_time_slots</code> is set to <code>0</code>.</p>"},{"location":"resource_constraints/#resourcetasksdistance","title":"ResourceTasksDistance","text":"<p>This constraint enforces a specific number of time unitary periods between tasks for a single resource. It can be applied within specified time intervals.</p> attribute type default description resource Union[Worker, CumulativeWorker] x The resource to which the constraint applies. distance int X The desired number of time unitary periods between tasks. list_of_time_intervals list None A list of time intervals within which the constraint is restricted. mode Literal[\"min\", \"max\", \"exact\"] \"exact\" The mode for enforcing the constraint <pre><code>worker_1 = ps.Worker(name=\"Worker1\")\n\nps.ResourceTasksDistance(\n    resource=worker_1,\n    distance=4,\n    mode=\"exact\",\n    list_of_time_intervals=[[10, 20], [30, 40]])\n</code></pre>"},{"location":"resource_constraints/#resourcenondelay","title":"ResourceNonDelay","text":"<p>A non-delay schedule is a type of feasible schedule where no machine is kept idle while there is an operation waiting for processing. Essentially, this approach prohibits unforced idleness.</p> <p><code>ResourceNonDelay</code> class is designed to prevent idle time for a resource when a task is ready for processing but forcing idle time to 0. That means that all tasks processed by this resource will be contiguous in the schedule, if ever a solution exists.</p> <pre><code>machine_1 = ps.Worker('Machine1')\nps.ResourceNonDelay(resource=worker_1)\n</code></pre>"},{"location":"resource_constraints/#distinctworkers","title":"DistinctWorkers","text":"<p>A <code>AllDifferentWorkers</code> constraint applies to two <code>SelectWorkers</code> instances, used to assign alternative resources to a task. It constraints the solver to select different workers for each <code>SelectWorkers</code>. For instance:</p> <pre><code>s1 = ps.SelectWorkers(list_of_workers=[worker_1, worker_2])\ns2 = ps.SelectWorkers(list_of_workers=[worker_1, worker_2])\n</code></pre> <p>could lead the solver to select worker_1 in both cases. Adding the following line:</p> <pre><code>cs = ps.DistinctWorkers(select_workers_1=s1,\n                        select_workers_2=s2)\n</code></pre> <p>let the solver selects the worker_1 for s1 and worker_2 for s2 or the opposite, worker_2 for s1 and worker_1 for s2. The cases where worker_1 is selected by both s1 and s2 or worker_2 by selected by both s1 and s2 are impossible.</p>"},{"location":"resource_constraints/#sameworkers","title":"SameWorkers","text":"<p>A <code>AllSameWorkers</code> constraint applies to two <code>SelectWorkers</code> instances. It constraints the solver to ensure both different <code>SelectWorkers</code> instances select the same worker. For example:</p> <pre><code>s1 = ps.SelectWorkers(list_of_workers=[worker_1, worker_2])\ns2 = ps.SelectWorkers(list_of_workers=[worker_1, worker_2])\n</code></pre> <p>could lead the solver to select worker_1 for s1 and worker_2 for s2. Adding the following line:</p> <pre><code>cs = ps.SameWorkers(select_workers_1=s1,\n                    select_workers_2=s2)\n</code></pre> <p>ensures either worker_1 is selected by both s1 and s2, or worker_2 is selected by both s1 and s2.</p>"},{"location":"run/","title":"Run","text":"<p>In order to check that the installation is successful and ProcessScheduler ready to run on your machine, edit/run the following example:</p> <pre><code>import processscheduler as ps \n\npb = ps.SchedulingProblem(name=\"Test\", horizon=10)\n\nT1 = ps.FixedDurationTask(name=\"T1\", duration=6)\nT2 = ps.FixedDurationTask(name=\"T2\", duration=4)\n\nW1 = ps.Worker(name=\"W1\")\n\nT1.add_required_resource(W1)\nT2.add_required_resource(W1)\n\nsolver = ps.SchedulingSolver(problem=pb)\n\nsolution = solver.solve()\nprint(solution)\n</code></pre> <p>If pandas is installed, you should get the following output:</p> <pre><code>Solver type:\n===========\n        -&gt; Standard SAT/SMT solver\nTotal computation time:\n=====================\n        Test satisfiability checked in 0.00s\n  Task name Allocated Resources  Start  End  Duration  Scheduled  Tardy\n0        T1                [W1]      0    6         6       True  False\n1        T2                [W1]      6   10         4       True  False\n</code></pre>"},{"location":"scheduling_problem/","title":"Scheduling problem","text":"<p>The <code>SchedulingProblem</code> class is the container for all modeling objects, such as tasks, resources and constraints.</p> <p>Note</p> <p>Creating a <code>SchedulingProblem</code> is the first step of the Python script. </p>"},{"location":"scheduling_problem/#time-slots-as-integers","title":"Time slots as integers","text":"<p>A <code>SchedulingProblem</code> instance holds a time interval: the lower bound of this interval (the initial time) is always 0, the upper bound (the final time) can be set by passing the <code>horizon</code> attribute, for example:</p> <pre><code>my_problem = SchedulingProblem(name='MySchedulingProblem',\n                               horizon=20)\n</code></pre> <p>The interval's duration is subdivided into discrete units called periods, each with a fixed duration of 1. The number of periods is equal to \\(horizon\\), and the number of points within the interval \\([0;horizon]\\) is \\(horizon+1\\).</p> <p></p> <p>Warning</p> <p>ProcessScheduler handles only variables using dimensionless integer values.</p> <p>A period represents the finest granularity level for defining the timeline, task durations, and the schedule itself. This timeline is dimensionless, allowing you to map a period to your desired duration, be it in seconds, minutes, hours, or any other unit. For instance:</p> <ul> <li>If your goal is to plan tasks within a single day, such as from 8 am to 6 pm (office hours), resulting in a 10-hour time span, and you intend to schedule tasks in 1-hour increments, then the horizon value should be set to 10 to achieve the desired number of periods:</li> </ul> \\[horizon = \\frac{18-8}{1}=10\\] <p>This implies that you can schedule tasks with durations measured in whole hours, making it impractical to schedule tasks with durations of half an hour or 45 minutes.</p> <ul> <li>If your task scheduling occurs in the morning, from 8 am to 12 pm, resulting in a 4-hour time interval, and you intend to schedule tasks in 1-minute intervals, then the horizon value must be 240:</li> </ul> \\[horizon = \\frac{12-8}{1/60}=240\\] <p>Note</p> <p>The <code>horizon</code> attribute is optional. If it's not explicitly provided during the <code>__init__</code> method, the solver will determine an appropriate horizon value that complies with the defined constraints. In cases where the scheduling problem aims to optimize the horizon, such as achieving a specific makespan objective, manual setting of the horizon is not necessary.</p>"},{"location":"scheduling_problem/#schedulingproblem-class-implementation","title":"SchedulingProblem class implementation","text":"Parameter name Type Mandatory/Optional Default Value Description name str Mandatory Problem name horizon int Optional None Problem horizon delta_time timedelta Optional None Value, in minutes, of one time unit start_time datetime.datetime Optional None The start date end_time datetime.time Optional None The end date <p>The only mandatory parameter is the problem <code>name</code>.</p> <p>If <code>horizon</code> is specified as an integer, the solver schedules tasks within the defined range, starting from \\(t=0\\) to \\(t=\\text{horizon}\\). If unspecified, the solver autonomously determines an appropriate horizon. The <code>horizon</code> parameter does not need to be provided. If an integer is passed, the solver will schedule all tasks between the initial time (\\(t=0\\)) and the horizon (\\(t=horizon\\)). If not, the solver will decide about a possible horizon.</p> <p>Note</p> <p>It is advisable to set the <code>horizon</code> parameter when the scheduling involves a predetermined period (e.g., a day, week, or month). This is particularly useful in scenarios aiming to minimize the scheduling horizon, such as in manufacturing scheduling where the goal is to reduce the time needed for processing jobs. In such cases, omitting the horizon allows the solver to optimize it based on problem requirements.</p>"},{"location":"scheduling_problem/#schedulingproblem-instantiation","title":"SchedulingProblem instantiation","text":"<p>Here is the simplest way to create <code>SchedulingProblem</code>.</p> <pre><code>import processscheduler as ps\nmy_problem = ps.SchedulingProblem(name=\"MyFirstSchedulingProblem\", horizon=100)\n</code></pre>"},{"location":"scheduling_problem/#mapping-integers-to-datetime-objects","title":"Mapping integers to datetime objects","text":"<p>To enhance the readability of Gantt charts and make schedules more intuitive, ProcessScheduler allows you to represent time intervals in real dates and times rather than integers. You can explicitly set time values in seconds, minutes, hours, and more. The smallest time duration for a task, represented by the integer <code>1</code>, can be mapped to a Python <code>timedelta</code> object. Similarly, any point in time can be mapped to a Python <code>datetime</code> object.</p> <p>Creating Python timedelta objects can be achieved as follows:</p> <pre><code>from datetime import timedelta\ndelta = timedelta(days=50,\n                  seconds=27,\n                  microseconds=10,\n                  milliseconds=29000,\n                  minutes=5,\n                  hours=8,\n                  weeks=2)\n</code></pre> <p>For Python <code>datetime</code> objects, you can create them like this:</p> <pre><code>from datetime import datetime\nnow = datetime.now()\n</code></pre> <p>These attribute values can be provided to the SchedulingProblem initialization method as follows:</p> <pre><code>problem = ps.SchedulingProblem(name='DateTimeBase',\n                               horizon=7,\n                               delta_time=timedelta(minutes=15),\n                               start_time=datetime.now())\n</code></pre> <p>Once the solver has completed its work and generated a solution, you can export the end times, start times, and durations to the Gantt chart or any other output format.</p> <p>Note</p> <p>For more detailed information on Python's datetime package documentation and its capabilities, please refer to the datetime Python package documentation. This documentation provides comprehensive guidance on working with date and time objects in Python.</p>"},{"location":"solving/","title":"Problem solving","text":"<p>Solving a scheduling problem involves the <code>SchedulingSolver</code> class.</p>"},{"location":"solving/#solver-definition","title":"Solver definition","text":"<p>A <code>SchedulingSolver</code> instance takes a <code>SchedulingProblem</code> instance:</p> <pre><code>solver = SchedulingSolver(problem=scheduling_problem_instance)\n</code></pre> <p>It takes the following optional arguments:</p> <ul> <li> <p><code>debug</code>: False by default, if set to True will output many useful information.</p> </li> <li> <p><code>max_time</code>: in seconds, the maximal time allowed to find a solution. Default is 10s.</p> </li> <li> <p><code>parallel</code>: boolean False by default, if True force the solver to be executed in multithreaded mode. It might be quicker. Or not.</p> </li> <li> <p><code>random_values</code>: a boolean, default to <code>False</code>. If set to <code>True</code>, enable a builtin generator to set random initial values. By setting this attribute to <code>True</code>, one expects the solver to give a different solution each time it is called.</p> </li> <li> <p><code>logics</code>: a string, None by default. Can be set to any of the supported z3 logics, \"QF_IDL\", \"QF_LIA\", etc. see https://smtlib.cs.uiowa.edu/logics.shtml. By default (logics set to None), the solver tries to find the best logics, but there can be significant improvements by setting a specific logics (\"QF_IDL\" or \"QF_UFIDL\" seems to give the best performances).</p> </li> <li> <p><code>verbosity</code>: an integer, 0 by default. 1 or 2 increases the solver verbosity. TO be used in a debugging or inspection purpose.</p> </li> <li> <p><code>optimizer</code>: a string, \"incremental\" by default, can be also set to \"optimize\". 1 or 2 increases the solver verbosity. TO be used in a debugging or inspection purpose.</p> </li> <li> <p><code>optimize_priority</code>: a string among \"pareto\", \"lex\", \"box\", \"weight\".</p> </li> </ul>"},{"location":"solving/#solve","title":"Solve","text":"<p>Just call the <code>solve</code> method. This method returns a <code>Solution</code> instance.</p> <pre><code>solution = solver.solve()\n</code></pre> <p>Running the <code>solve</code> method returns can either fail or succeed, according to the 4 following cases:</p> <ol> <li>The problem cannot be solved because some constraints are contradictory. It is called \"Unsatisfiable\". The <code>solve</code> method returns False. For example:</li> </ol> <pre><code>TaskStartAt(task=cook_the_chicken, value=2)\nTaskStartAt(task=cook_the_chicken, value=3)\n</code></pre> <p>It is obvious that these constraints cannot be both satisfied.</p> <ol> <li> <p>The problem cannot be solved for an unknown reason (the satisfiability of the set of constraints cannot be computed). The <code>solve</code> method returns False.</p> </li> <li> <p>The solver takes too long to complete and exceeds the allowed <code>max_time</code>. The <code>solve</code> method returns False.</p> </li> <li> <p>The solver successes in finding a schedule that satisfies all the constraints. The <code>solve</code> method returns the solution, which can be rendered as a Gantt chart or a JSON string.</p> </li> </ol> <p>Note</p> <p>If the solver fails to give a solution, increase the <code>max_time</code> (case 2) or remove some constraints (case 1).</p>"},{"location":"solving/#find-another-solution","title":"Find another solution","text":"<p>The solver may schedule:</p> <ul> <li> <p>one solution among many, in the case where there is no optimization,</p> </li> <li> <p>the best possible schedule in case of an optimization issue.</p> </li> </ul> <p>In both cases, you may need to check a different schedule that fits all the constraints. Use the <code>find_another_solution</code> method and pass the variable you would want the solver to look for another solution.</p> <p>Note</p> <p>Before requesting another solution, the <code>solve</code> method has first to be executed, i.e. there should already be a current solution.</p> <p>You can pass any variable to the <code>find_another_solution</code> method: a task start, a task end, a task duration, a resource productivity etc.</p> <p>For example, there are 5 different ways to schedule a FixedDurationTask with a duration=2 in an horizon of 6. The default solution returned by the solver is:</p> <pre><code>problem = ps.SchedulingProblem(name='FindAnotherSolution', horizon=6)\ntask_1 = ps.FixedDurationTask(name='task1', duration=2)\nproblem.add_task(task_1)\nsolver = ps.SchedulingSolver(problem=problem)\nsolution = solver.solve()\nprint(\"Solution for task_1.start:\", solution.tasks['task1'])\n</code></pre> <pre><code>Solution for task_1.start: 0\n</code></pre> <p>Then, we can request for another solution:</p> <pre><code>solution = solver.find_another_solution(task_1.start)\nif solution is not None:\n    print(\"New solution for task_1.start:\", solution.tasks['task1'])\n</code></pre> <pre><code>Solution for task_1.start: 1\n</code></pre> <p>You can recursively call <code>find_another_solution</code> to find all possible solutions, until the solver fails to return a new one.</p>"},{"location":"solving/#run-in-debug-mode","title":"Run in debug mode","text":"<p>If the <code>debug</code> attribute is set to True, the z3 solver is run with the unsat_core option. This will result in a much longer computation time, but this will help identifying the constraints that conflict. Because of this higher consumption of resources, the <code>debug</code> flag should be used only if the solver fails to find a solution.</p>"},{"location":"solving/#optimization","title":"Optimization","text":"<p>Please refer to the Objectives page for further details.</p>"},{"location":"solving/#gantt-chart","title":"Gantt chart","text":"<p>Please refer to the Gantt chart page for further details.</p>"},{"location":"solving/#logics","title":"Logics","text":"logics computing_time(s) flowtime priority obj value QF_LRA 2.84 147 289 436 QF_LIA 4.25 165 320 485 QF_RDL 0.48 None None None QF_IDL 3.45 174 339 513 QF_AUFLIA 6.01 129 270 399 QF_ALIA 3.69 139 280 419 QF_AUFLIRA 4.30 145 266 411 QF_AUFNIA 4.41 159 337 496 QF_AUFNIRA 5.35 168 310 478 QF_ANIA 6.12 168 320 488 QF_LIRA 5.41 151 302 453 QF_UFLIA 6.18 143 296 439 QF_UFLRA 9.19 143 305 448 QF_UFIDL 4.98 132 263 395 QF_UFRDL 5.69 171 352 523 QF_NIRA 6.72 142 268 410 QF_UFNRA 8.51 160 300 460 QF_UFNIA 18.89 130 261 391 QF_UFNIRA 6.36 171 320 491 QF_S 5.28 152 289 441 QF_SLIA 4.33 174 361 535 UFIDL 6.70 126 246 372 HORN 0.49 None None None QF_FPLRA 6.21 129 253 382"},{"location":"task/","title":"Task","text":"<p>According to the APICS dictionary, a task may either be:</p> <ol> <li> <p>In project management, the lowest level to which work can be divided on a project</p> </li> <li> <p>In activity-based cost accounting, a task, a subdivision of an activity, is the least amount of work. Tasks are used to describe activities.</p> </li> </ol> <p>In the context of this software library, the concept of a task aligns with the first definition : the lowest level to which work can be divided on a project. ProcessScheduler's primary objective is to compute a chronological sequence, or temporal order, for a collection of tasks while adhering to a specific set of constraints. Three types of <code>Task</code> may be used to represent a scheduling problem : ZeroDurationTask, FixedDurationTask and VariableDurationTask. They follow the inheritance class diagram represented below.</p>"},{"location":"task/#task-model","title":"Task model","text":"<p>A <code>Task</code> instance is basically a time interval, defined by the three following parameters:</p> <ul> <li> <p><code>start</code>: a point in the \\([0, horizon]\\) integer interval. If the task is scheduled, then \\(start&gt;=0\\)</p> </li> <li> <p><code>end</code>: a point in the \\([0, horizon]\\) integer interval. If the task is scheduled, then \\(end&gt;=start\\) and \\(end&lt;=horizon\\)</p> </li> <li> <p><code>duration</code>: a integer number of periods, such as \\(duration=end-start\\)</p> </li> </ul> <p></p> <pre><code>classDiagram\n  Task &lt;|-- ZeroDurationTask\n  Task &lt;|-- FixedDurationTask\n  Task &lt;|-- VariableDurationTask\nclass Task{\n    +str name\n    +bool optional\n    +int release_date\n    +int due_date\n    +bool due_date_is_deadline\n    +int priority\n    +int work_amount\n}\nclass FixedDurationTask{\n    +int duration\n}\nclass VariableDurationTask{\n    +int min_duration\n    +int max_duration\n    +list allowed_durations\n}</code></pre> <p>Warning</p> <p>The <code>Task</code> class has to be considered as an abstract class that should not be instantiated. Use any of its three specialization (<code>ZeroDurationTask</code>, <code>FixedDurationTask</code> or <code>VariableDurationTask</code>) to represent your scheduling problem.</p> <p>The <code>Task</code> class and its derivatives represent any activity. The parameters for the creation of a <code>Task</code> are the following:</p> Parameter name Type Default Value Description name str unique string The name of the task must be unique among all other tasks optional bool False If the task is optional release_date int None Also be referred to as the ready date. It is the time the job arrives at the system, i.e., the earliest time at which the task can start its processing due_date int None the committed shipping or completion date (i.e., the date the job is promised to the customer) due_date_is_deadline bool False if <code>False</code>, completion of the task after its due date is allowed, but then a penalty is incurred. If <code>True</code> the task cannot be scheduled after its due_date priority int 1 A number denoting the importance of the task relative to the other tasks in the system. A task with a priority of 10 should be considered as 10 times more important than a task with a priority of 1 work_amount int 0 the quantity of work necessary to be completed by all the resources assigned <p>Additional parameters for the <code>FixedDurationTask</code> class.</p> Parameter name Type Default Value Description duration int The task duration, such that \\(duration=end-start\\) <p>Additional parameters for the <code>VariableDurationTask</code> class.</p> Parameter name Type Default Value Description min_duration int 0 Minimal task duration max_duration int None Maximal task duration allowed_duration list None List of possible task durations <pre><code># Example: The duration of this task depends on the number\n# of workers handling boxes.\nmove_boxes = VariableDurationTask(name='MoveBoxesFromMachineAToInventory')\n</code></pre> <p>Warning</p> <p>Each <code>Task</code> instance must have a unique name in the scheduling problem. To prevent that two tasks share the same name, ProcessScheduler raises an exception if ever a task with an existing name is already created.</p> <p>Three <code>Task</code> derivative classes can be used to represent a task: <code>FixedDurationTask</code>, <code>ZeroDurationTask</code>, <code>VariableDurationTask</code>.</p>"},{"location":"task/#fixeddurationtask-class","title":"FixedDurationTask class","text":"<p>The duration of a <code>FixedDurationTask</code> is known a priori. You must pass the task <code>name</code> and <code>duration</code> arguments when creating the instance:</p> <pre><code># I assume one period to be mapped to 15min, cooking will be 1.5 hour\n# so the chicken requires 6*15mn=1.5h to be cooked\ncook_chicken = FixedDurationTask(name='CookChicken',\n                                 duration=6)\n</code></pre>"},{"location":"task/#zerodurationtask-class","title":"ZeroDurationTask class","text":"<p>A <code>ZeroDurationTask</code> is a FixedDurationTask where \\(duration=0\\), that is to say \\(start=end\\). Useful to represent project milestones, or other important points in time.</p> <pre><code>project_kickup = ZeroDurationTask(name='KickUp')\n</code></pre>"},{"location":"task/#variabledurationtask-class","title":"VariableDurationTask class","text":"<p>A <code>VariableDurationTask</code> represents a task for which the duration is not known. The solver is expected to find a duration that satisfies the constraints (the duration may depend on the number of resources assigned to the task). You can bound the duration by using <code>max_duration</code> and/or <code>min_duration</code> parameters.</p> <pre><code># 48h max to get done\nplant_wheat_seeds = VariableDurationTask(name='PlantWheatSeeds',\n                                         max_duration=48)\n</code></pre> <p>A <code>VariableDurationTask</code> duration can be selected among a list of possible durations. The solver decides the duration.</p> <pre><code># either 1 or 2 hour for an english lesson\nenglish_lesson = VariableDurationTask(name='EnglishLesson',\n                                      allowed_durations = [1, 2])\n</code></pre>"},{"location":"task/#advanced-parameters","title":"Advanced parameters","text":""},{"location":"task/#work-amount","title":"Work amount","text":"<p>The <code>work_amount</code> is the total amount of work that the <code>Task</code> must provide. It is set to <code>0</code> by default. The <code>work_amount</code> is a dimensionless positive integer value, it can be mapped to any unit according to the physical meaning of the work amount. For example, if the task target is to move small pieces of wood from one point to another, then the work_amount maybe 166000 if 166000 pieces of woods are to be moved. In a maintenance task, if there are 8 screws to unscrew, the UnScrew work_amount will be set to 8.</p>"},{"location":"task/#temporal-priority","title":"Temporal priority","text":"<p>The <code>priority</code> of a task is a positive integer that can take any value. It is not bounded. A task with a higher priority will be scheduled earlier than a task with a lower priority. If the solver is requested to optimize the global schedule in terms of task priorities (a \"priority objective\") then a task with a high priority may be scheduled before a task with a lower priority.</p>"},{"location":"task/#optional","title":"Optional","text":"<p>All tasks instances are mandatory by default: the solver has to find a solution where all tasks are actually scheduled. However, tasks instances can be turned into optional tasks, by setting the <code>optional</code> flag to <code>True</code>:</p> <pre><code># 10mn to clean the table. This is an optional task\nclean_the_table_after_meal = FixedDurationTasks(name='CleanTable',\n                                                duration=10,\n                                                optional=True)\n</code></pre> <p>An optional task may or may not be scheduled by the solver. It depends on the constraints that bound the scheduling problem.</p>"},{"location":"task_constraints/","title":"Task Constraints","text":"<p>The ProcessScheduler framework provides a powerful set of predefined temporal task constraints to facilitate the expression of common scheduling rules efficiently. These constraints empower you to articulate task-related regulations, such as fixed start times, synchronized endings, precedence relationships, and more.</p> <p>The <code>TaskConstraint</code> class is a specialized extension of the generic <code>Constraint</code> class, forming the foundation for expressing task-related scheduling rules.</p> <pre><code>classDiagram\n  Constraint &lt;|-- TaskConstraint</code></pre> <p>Note</p> <p>Constraint names that start with <code>Task*</code> apply to a single task, while those starting with <code>Tasks***</code> apply to two or more task instances.</p> <p>Note</p> <p>All Task constraints can be defined as either mandatory or optional. By default, constraints are mandatory (parameter optional=False). If you set the optional attribute to True, the constraint becomes optional and may or may not apply based on the solver's discretion. You can force the schedule to adhere to an optional constraint using the task.applied attribute:</p> <pre><code>pb.add_constraint([task.applied == True])\n</code></pre>"},{"location":"task_constraints/#single-task-temporal-constraints","title":"Single task temporal constraints","text":"<p>These constraints apply to individual tasks.</p> <pre><code>classDiagram\n  TaskConstraint &lt;|-- TaskStartAt\n  TaskConstraint &lt;|-- TaskStartAfter\n  TaskConstraint &lt;|-- TaskEndAt\n  TaskConstraint &lt;|-- TaskEndBefore\nclass TaskStartAt{\n    +Task task\n    +int value\n}\nclass TaskStartAfter{\n    +Task task\n    +int value\n    +str kind    \n}\nclass TaskEndAt{\n    +Task task\n    +int value\n}\nclass TaskEndBefore{\n    +Task task\n    +int value\n    +str kind\n}</code></pre> Type Math Description TaskStartAt \\(task.start = value\\) starts exactly at the instant <code>value</code> TaskStartAfter \\(task.start &gt;= value\\) task must start after a given time instant TaskEndAt \\(task.end = value\\) task ends exactly at the specified time instant TaskEndBefore \\(task.end &lt;= value\\) task ends before or at a given time instant <p><code>TaskStart/End/After/Before</code> constraint can be strict (\\(&gt;\\),\\(&lt;\\)) or lax (\\(&gt;=\\),\\(&lt;=\\)) whether the <code>kind</code> argument is set to <code>'lax'</code> or <code>'strict'</code>. The default value is <code>'lax'</code>.</p> <p>Example: <pre><code>task1 = FixedDurationTask(name=\"Task1\", duration=10)\nTaskStarAfter(task= task1, value=7, kind=\"strict\")\n</code></pre></p>"},{"location":"task_constraints/#two-tasks-temporal-constraints","title":"Two tasks temporal constraints","text":"<p>These constraints apply to sets of two tasks.</p> <pre><code>classDiagram\n  TaskConstraint &lt;|-- TaskPrecedence\n  TaskConstraint &lt;|-- TasksStartSynced\n  TaskConstraint &lt;|-- TasksEndSynced\n  TaskConstraint &lt;|-- TasksDontOverlap\nclass TaskPrecedence{\n    +Task task_before\n    +Task task_after\n    +str kind\n    +int offset\n}\n</code></pre>"},{"location":"task_constraints/#taskprecedence","title":"TaskPrecedence","text":"<p>Ensures that one task is scheduled before another. The precedence can be either 'lax,' 'strict,' or 'tight,' and an optional offset can be applied.</p> <p>The <code>TaskPrecedence</code> class takes two parameters <code>task_1</code> and <code>task_2</code> and constraints <code>task_2</code> to be scheduled after <code>task_1</code> is completed. </p> <p>The <code>kind</code> constraint can be</p> <ul> <li><code>'tight'</code>  (t1.end == t2.start)</li> <li><code>'lax'</code>  (t1.end &lt;= t2.start)</li> <li><code>'strict'</code>  (t1.end &lt; t2.start)</li> </ul> <p>The default value is <code>'lax'</code>.</p> <p>An optional parameter <code>offset</code> can be additionally set:</p> <p><pre><code>task_1 = ps.FixedDurationTask(name='Task1', duration=3)\ntask_2 = ps.FixedVariableTask(name='Task2')\npc = TaskPrecedence(task_before=task1,\n                    task_after=task2,\n                    kind='tight',\n                    offset=2)\n</code></pre> constraints the solver to schedule task_2 start exactly 2 periods after task_1 is completed.</p>"},{"location":"task_constraints/#tasksstartsynced","title":"TasksStartSynced","text":"<p>Specify that two tasks must start at the same time.</p> <p><code>TasksStartSynced</code> takes two parameters <code>task_1</code> and <code>task_2</code> such as the schedule must satisfy the constraint :math:<code>task_1.start = task_2.start</code></p> <p></p>"},{"location":"task_constraints/#tasksendsynced","title":"TasksEndSynced","text":"<p>Specify that two tasks must end at the same time.</p> <p><code>TasksEndSynced</code> takes two parameters <code>task_1</code> and <code>task_2</code> such as the schedule must satisfy the constraint :math:<code>task_1.end = task_2.end</code></p> <p></p>"},{"location":"task_constraints/#tasksdontoverlap","title":"TasksDontOverlap","text":"<p>Ensures that two tasks should not overlap in time.</p> <p><code>TasksDontOverlap</code> takes two parameters <code>task_1</code> and <code>task_2</code> such as the task_1 ends before the task_2 is started or the opposite (task_2 ends before task_1 is started)</p> <p></p>"},{"location":"task_constraints/#multiple-tasks-temporal-constraints","title":"Multiple tasks temporal constraints","text":""},{"location":"task_constraints/#taskscontiguous","title":"TasksContiguous","text":"<p>Forces a set of tasks to be scheduled contiguously.</p> <p><code>TasksContiguous</code> takes a list of tasks and forces the schedule so that tasks are contiguous.</p>"},{"location":"task_constraints/#unorderedtaskgroup","title":"UnorderedTaskGroup","text":"<p>An UnorderedTaskGroup represents a collection of tasks that can be scheduled in any order. This means that the tasks within this group do not have a strict temporal sequence.</p>"},{"location":"task_constraints/#orderedtaskgroup","title":"OrderedTaskGroup","text":"<p>A set of tasks that can be scheduled in a specified order, with time bounds. The <code>kind</code> constraint can be </p> <ul> <li><code>'tight'</code> (t1.end == t2.start)</li> <li><code>'lax'</code> (t1.end &lt;= t2.start)</li> <li><code>'strict'</code> (t1.end &lt; t2.start)</li> </ul> <p>The default value is <code>'lax'</code>.</p>"},{"location":"task_constraints/#advanced-tasks-constraints","title":"Advanced tasks constraints","text":""},{"location":"task_constraints/#schedulentasksintimeintervals","title":"ScheduleNTasksInTimeIntervals","text":"<p>Schedules a specific number of tasks within defined time intervals.</p> <p>Given a list of :math:<code>m</code> tasks, and a list of time intervals, <code>ScheduleNTasksInTimeIntervals</code> schedule :math:<code>N</code> tasks among :math:<code>m</code> in this time interval.</p>"},{"location":"task_constraints/#resourcetasksdistance","title":"ResourceTasksDistance","text":"<p>Defines constraints on the temporal distance between tasks using a shared resource.</p> <p><code>ResourceTasksDistance</code> takes a mandatory attribute <code>distance</code> (integer), an optional <code>time_periods</code> (list of couples of integers e.g. [[0, 1], [5, 19]]). All tasks, that use the given resource, scheduled within the <code>time_periods</code> must have a maximal distance of <code>distance</code> (distance being considered as the time between two consecutive tasks).</p> <p>Note</p> <p>If the task(s) is (are) optional(s), all these constraints apply only if the task is scheduled. If the solver does not schedule the task, these constraints does not apply.</p>"},{"location":"task_constraints/#optional-task-constraints","title":"Optional task constraints","text":""},{"location":"task_constraints/#optionaltaskforceschedule","title":"OptionalTaskForceSchedule","text":"<p>Force an optional task to be (un)scheduled.</p>"},{"location":"task_constraints/#optionaltaskconditionschedule","title":"OptionalTaskConditionSchedule","text":"<p>Creates a constraint that schedules a task based on a specified Boolean condition.</p> <p><code>OptionalTaskConditionSchedule</code> creates a constraint that adds a condition for the task to be scheduled. The condition is a z3 BoolRef</p>"},{"location":"task_constraints/#optionaltasksdependency","title":"OptionalTasksDependency","text":"<p><code>OptionalTasksDependency</code> takes two optional tasks <code>task_1</code> and <code>task_2</code>, and ensures that if task_1 is scheduled then that task_2 is forced to be scheduled as well.</p>"},{"location":"task_constraints/#forceschedulenoptionaltasks","title":"ForceScheduleNOptionalTasks","text":"<p>Forces the scheduling of a specified number of optional tasks out of a larger set of optional tasks.</p> <p><code>ForceScheduleNOptionalTasks</code> forces :math:<code>m</code> optional tasks among :math:<code>n</code> to be scheduled, with :math:<code>m \\leq n</code>.</p>"},{"location":"use-case-flow-shop/","title":"Use case: flowshop scheduling","text":"<p>This example is based on the paper from Tao et al. (2015), where authors present an introduction example. In a flow shop problem, a set of \\(n\\) jobs has to be processed on \\(m\\) different machines in the same order. Job \\(j\\), \\(j=1,2,...,n\\) is processed on machines \\(i\\), \\(i=1,2,..,m\\), with a nonnegative processing time \\(p(i,j)\\) and a release date \\(r_j\\), which is the earliest time when the job is permitted to process. Each machine can process at most one job and each job can be handled by at most one machine at any given time. The machine processes the jobs in a first come, first served manner. The goal is to determine a job sequence that minimizes the makespan. The problem statement is:</p> <p></p> <p>The following solution is reported by the authors (order J1, J3, J4, J2, scheduled horizon: 29):</p> <p></p> <p>In this notebook, we try to reproduce the results reported by the authors.</p> <p>Reference</p> <p>Tao Ren, Meiting Guo, Lin Lin, Yunhui Miao, \"A Local Search Algorithm for the Flow Shop Scheduling Problem with Release Dates\", Discrete Dynamics in Nature and Society, vol. 2015, Article ID 320140, 8 pages, 2015. https://doi.org/10.1155/2015/320140</p>"},{"location":"use-case-flow-shop/#imports","title":"Imports","text":"<pre><code>import processscheduler as ps\n\n%config InlineBackend.figure_formats = ['svg']\n</code></pre>"},{"location":"use-case-flow-shop/#create-the-scheduling-problem","title":"Create the scheduling problem","text":"<p>The total horizon is unknown, leave it empty and only set the problem name.</p> <pre><code>flow_shop_problem = ps.SchedulingProblem(name=\"FlowShop\")\n</code></pre>"},{"location":"use-case-flow-shop/#create-the-3-machines-m1-m2-and-m3","title":"Create the 3 machines M1, M2 and M3","text":"<pre><code>M3 = ps.Worker(name=\"M3\")\nM2 = ps.Worker(name=\"M2\")\nM1 = ps.Worker(name=\"M1\")\n</code></pre>"},{"location":"use-case-flow-shop/#create-jobs-j1-j2-j3-and-j4-related-tasks","title":"Create jobs J1, J2, J3 and J4 - related tasks","text":"<pre><code># J1\nJ11 = ps.FixedDurationTask(name=\"J11\", duration=2)\nJ12 = ps.FixedDurationTask(name=\"J12\", duration=5)\nJ13 = ps.FixedDurationTask(name=\"J13\", duration=6)\n\n# J2\nJ21 = ps.FixedDurationTask(name=\"J21\", duration=1)\nJ22 = ps.FixedDurationTask(name=\"J22\", duration=5)\nJ23 = ps.FixedDurationTask(name=\"J23\", duration=7)\n\n# J3\nJ31 = ps.FixedDurationTask(name=\"J31\", duration=1)\nJ32 = ps.FixedDurationTask(name=\"J32\", duration=4)\nJ33 = ps.FixedDurationTask(name=\"J33\", duration=1)\n\n# J4\nJ41 = ps.FixedDurationTask(name=\"J41\", duration=3)\nJ42 = ps.FixedDurationTask(name=\"J42\", duration=4)\nJ43 = ps.FixedDurationTask(name=\"J43\", duration=7)\n</code></pre>"},{"location":"use-case-flow-shop/#assign-resources","title":"Assign resources","text":"<p>One machine per task.</p> <pre><code>J11.add_required_resource(M1)\nJ12.add_required_resource(M2)\nJ13.add_required_resource(M3)\n\nJ21.add_required_resource(M1)\nJ22.add_required_resource(M2)\nJ23.add_required_resource(M3)\n\nJ31.add_required_resource(M1)\nJ32.add_required_resource(M2)\nJ33.add_required_resource(M3)\n\nJ41.add_required_resource(M1)\nJ42.add_required_resource(M2)\nJ43.add_required_resource(M3)\n</code></pre>"},{"location":"use-case-flow-shop/#constraint-release-dates","title":"Constraint: release dates","text":"<pre><code>r1 = 0\nr2 = 9\nr3 = 2\nr4 = 7\n\nps.TaskStartAfter(task=J11, value=r1)\nps.TaskStartAfter(task=J12, value=r1)\nps.TaskStartAfter(task=J13, value=r1)\n\nps.TaskStartAfter(task=J21, value=r2)\nps.TaskStartAfter(task=J22, value=r2)\nps.TaskStartAfter(task=J23, value=r2)\n\nps.TaskStartAfter(task=J31, value=r3)\nps.TaskStartAfter(task=J32, value=r3)\nps.TaskStartAfter(task=J33, value=r3)\n\nps.TaskStartAfter(task=J41, value=r4)\nps.TaskStartAfter(task=J42, value=r4)\nps.TaskStartAfter(task=J43, value=r4)\n</code></pre> <pre><code>TaskStartAfter_30661442(&lt;class 'processscheduler.task_constraint.TaskStartAfter'&gt;)\n1 assertion(s):\nJ43_start &gt;= 7\n</code></pre>"},{"location":"use-case-flow-shop/#constraints-precedences","title":"Constraints: precedences","text":"<p>All jobs should be scheduled in the same ordre on each machine. The constraint is expressed as following: all J2 tasks must be scheduled before Or after J2 tasks, AND all J3 tasks must be scheduled before OR oafter J1 tasks etc.</p> <pre><code>J1 = [J11, J12, J13]\nJ2 = [J21, J22, J23]\nJ3 = [J31, J32, J33]\nJ4 = [J41, J42, J43]\n\n# we need to combinations function of the itertools module,\n# to compute all pairs from the list of jobs.\nfrom itertools import combinations\n\nfor Ja, Jb in combinations([J1, J2, J3, J4], 2):\n    befores = []\n    afters = []\n    for i in range(3):\n        Ja_before_Jb = ps.TaskPrecedence(task_before=Ja[i], task_after=Jb[i])\n        Ja_after_Jb = ps.TaskPrecedence(task_before=Jb[i], task_after=Ja[i])\n        befores.append(Ja_before_Jb)\n        afters.append(Ja_after_Jb)\n    ps.Xor(constraint_1=ps.And(list_of_constraints=befores), constraint_2=ps.And(list_of_constraints=afters))\n</code></pre>"},{"location":"use-case-flow-shop/#add-a-makespan-objective","title":"Add  a makespan objective","text":"<pre><code>makespan_obj = ps.ObjectiveMinimizeMakespan()\n</code></pre>"},{"location":"use-case-flow-shop/#solution-plot-the-schedule","title":"Solution, plot the schedule","text":"<pre><code>solver = ps.SchedulingSolver(problem=flow_shop_problem)\nsolution = solver.solve()\nps.render_gantt_matplotlib(solution, fig_size=(10, 5), render_mode=\"Resource\")\n</code></pre> <pre><code>Solver type:\n===========\n    -&gt; Standard SAT/SMT solver\nIncremental optimizer:\n======================\n    Found value: 28 elapsed time:0.011s\n    Checking better value &lt; 28\n    Found value: 22 elapsed time:0.012s\n    Checking better value &lt; 22\n    Found value: 21 elapsed time:0.012s\n    Checking better value &lt; 21\n    Can't find a better solution for problem FlowShop.\n\n    Found optimum 21. Stopping iteration.\n    total number of iterations: 4\n    value: 21\n    FlowShop satisfiability checked in 0.01s\n</code></pre> <p>We confirm the job sort from Tao et al. (2015) (J1 then J3, J4 and finally J2). The horizon is here only 21.</p>"},{"location":"use-case-formula-one-change-tires/","title":"Use case: formula one pitstop","text":"<p>This example is based on the DailyMail blog entry https://www.dailymail.co.uk/sport/formulaone/article-4401632/Formula-One-pit-stop-does-crew-work.html where a nice image shows 21 people changing the 4 tires of a Formula 1 Ferrari. In this example, only 16 out 21 people are represented. This notebook can be tested online at mybinder.org</p> <pre><code>from IPython.display import YouTubeVideo\n\nYouTubeVideo(\"aHSUp7msCIE\", width=800, height=300)\n</code></pre>"},{"location":"use-case-formula-one-change-tires/#imports","title":"Imports","text":"<pre><code>import processscheduler as ps\n\n%config InlineBackend.figure_formats = ['svg']\n</code></pre>"},{"location":"use-case-formula-one-change-tires/#create-the-scheduling-problem","title":"Create the scheduling problem","text":"<p>The total horizon is not knwown, leave it empty and only set the problem name.</p> <pre><code>change_tires_problem = ps.SchedulingProblem(name=\"ChangeTires\")\n</code></pre>"},{"location":"use-case-formula-one-change-tires/#create-the-16-available-resources","title":"Create the 16 available resources","text":"<p>Each people in and around the car is represented as a worker.</p> <pre><code>nb_lifters = 2\nnb_gunners = 4\nnb_tyre_handlers = 8\nnb_stabilizers = 2\n</code></pre> <pre><code># Lift tasks\nlifters = [ps.Worker(name=\"JackOperator%i\" % (i + 1)) for i in range(nb_lifters)]\ngunners = [ps.Worker(name=\"Gunner%i\" % (i + 1)) for i in range(nb_gunners)]\ntyre_handlers = [ps.Worker(name=\"Handler%i\" % (i + 1)) for i in range(nb_tyre_handlers)]\nstabilizers = [ps.Worker(name=\"Stabilizer%i\" % (i + 1)) for i in range(nb_stabilizers)]\n</code></pre>"},{"location":"use-case-formula-one-change-tires/#create-tasks-and-assign-resources","title":"Create tasks and assign resources","text":"<p>One period is mapped to one second. For example, if lifting the rear take 2sec then the duration will be set to 2.</p> <pre><code># lift tasks and lifters\n# both lift tasks can be processed by any one of the lifters\nlift_rear_up = ps.FixedDurationTask(name=\"LiftRearUp\", duration=2)\nlift_front_up = ps.FixedDurationTask(name=\"LiftFrontUp\", duration=2)\nlift_rear_up.add_required_resource(lifters[0])\nlift_front_up.add_required_resource(lifters[1])\n\nlift_rear_down = ps.FixedDurationTask(name=\"LiftRearDown\", duration=2)\nlift_front_down = ps.FixedDurationTask(name=\"LiftFrontDown\", duration=2)\nlift_rear_down.add_required_resource(lifters[0])\nlift_front_down.add_required_resource(lifters[1])\n\n# unscrew tasks\nunscrew_front_left_tyre = ps.FixedDurationTask(name=\"UnScrewFrontLeftTyre\", duration=2)\nunscrew_front_right_tyre = ps.FixedDurationTask(\n    name=\"UnScrewFrontRightTyre\", duration=2\n)\nunscrew_rear_left_tyre = ps.FixedDurationTask(name=\"UnScrewRearLeftTyre\", duration=2)\nunscrew_rear_right_tyre = ps.FixedDurationTask(name=\"UnScrewRearRightTyre\", duration=2)\n\ngunner_unscrew_front_left_tyre = ps.SelectWorkers(\n    list_of_workers=gunners, nb_workers_to_select=1\n)\nunscrew_front_left_tyre.add_required_resource(gunner_unscrew_front_left_tyre)\n\ngunner_unscrew_front_right_tyre = ps.SelectWorkers(\n    list_of_workers=gunners, nb_workers_to_select=1\n)\nunscrew_front_right_tyre.add_required_resource(gunner_unscrew_front_right_tyre)\n\ngunner_unscrew_rear_left_tyre = ps.SelectWorkers(\n    list_of_workers=gunners, nb_workers_to_select=1\n)\nunscrew_rear_left_tyre.add_required_resource(gunner_unscrew_rear_left_tyre)\n\ngunner_unscrew_rear_right_tyre = ps.SelectWorkers(\n    list_of_workers=gunners, nb_workers_to_select=1\n)\nunscrew_rear_right_tyre.add_required_resource(gunner_unscrew_rear_right_tyre)\n\n# screw tasks and gunners\nscrew_front_left_tyre = ps.FixedDurationTask(name=\"ScrewFrontLeftTyre\", duration=2)\nscrew_front_right_tyre = ps.FixedDurationTask(name=\"ScrewFrontRightTyre\", duration=2)\nscrew_rear_left_tyre = ps.FixedDurationTask(name=\"ScrewRearLeftTyre\", duration=2)\nscrew_rear_right_tyre = ps.FixedDurationTask(name=\"ScrewRearRightTyre\", duration=2)\n\ngunner_screw_front_left_tyre = ps.SelectWorkers(list_of_workers=gunners)\nscrew_front_left_tyre.add_required_resource(gunner_screw_front_left_tyre)\n\ngunner_screw_front_right_tyre = ps.SelectWorkers(list_of_workers=gunners)\nscrew_front_right_tyre.add_required_resource(gunner_screw_front_right_tyre)\n\ngunner_screw_rear_left_tyre = ps.SelectWorkers(list_of_workers=gunners)\nscrew_rear_left_tyre.add_required_resource(gunner_screw_rear_left_tyre)\n\ngunner_screw_rear_right_tyre = ps.SelectWorkers(list_of_workers=gunners)\nscrew_rear_right_tyre.add_required_resource(gunner_screw_rear_right_tyre)\n</code></pre> <pre><code># tires OFF and handlers\nfront_left_tyre_off = ps.FixedDurationTask(name=\"FrontLeftTyreOff\", duration=2)\nfront_right_tyre_off = ps.FixedDurationTask(name=\"FrontRightTyreOff\", duration=2)\nrear_left_tyre_off = ps.FixedDurationTask(name=\"RearLeftTyreOff\", duration=2)\nrear_right_tyre_off = ps.FixedDurationTask(name=\"RearRightTyreOff\", duration=2)\n\nfor tyre_off_task in [\n    front_left_tyre_off,\n    front_right_tyre_off,\n    rear_left_tyre_off,\n    rear_right_tyre_off,\n]:\n    tyre_off_task.add_required_resource(ps.SelectWorkers(list_of_workers=tyre_handlers))\n\n# tires ON and handlers, same as above\nfront_left_tyre_on = ps.FixedDurationTask(name=\"FrontLeftTyreOn\", duration=2)\nfront_right_tyre_on = ps.FixedDurationTask(name=\"FrontRightTyreOn\", duration=2)\nrear_left_tyre_on = ps.FixedDurationTask(name=\"RearLeftTyreOn\", duration=2)\nrear_right_tyre_on = ps.FixedDurationTask(name=\"RearRightTyreOn\", duration=2)\n\nfor tyre_on_task in [\n    front_left_tyre_on,\n    front_right_tyre_on,\n    rear_left_tyre_on,\n    rear_right_tyre_on,\n]:\n    tyre_on_task.add_required_resource(ps.SelectWorkers(list_of_workers=tyre_handlers))\n</code></pre> <p>Stabilizers start their job as soon as the car is stopped until the end of the whole activity.</p> <p><pre><code>stabilize_left = ps.VariableDurationTask(name=\"StabilizeLeft\")\nstabilize_right = ps.VariableDurationTask(name=\"StabilizeRight\")\n\nstabilize_left.add_required_resource(stabilizers[0])\nstabilize_right.add_required_resource(stabilizers[1])\n\nps.TaskStartAt(task=stabilize_left, value=0)\nps.TaskStartAt(task=stabilize_right, value=0)\n\nps.TaskEndAt(task=stabilize_left, value=change_tires_problem._horizon)\nps.TaskEndAt(task=stabilize_right, value=change_tires_problem._horizon)\n</code></pre> <pre><code>    TaskEndAt_31695862(&lt;class 'processscheduler.task_constraint.TaskEndAt'&gt;)\n    1 assertion(s):\n    StabilizeRight_end == horizon\n</code></pre></p>"},{"location":"use-case-formula-one-change-tires/#task-precedences","title":"Task precedences","text":"<pre><code># front left tyre operations\nfr_left = [\n    unscrew_front_left_tyre,\n    front_left_tyre_off,\n    front_left_tyre_on,\n    screw_front_left_tyre,\n]\nfor i in range(len(fr_left) - 1):\n    ps.TaskPrecedence(task_before=fr_left[i], task_after=fr_left[i + 1])\n# front right tyre operations\nfr_right = [\n    unscrew_front_right_tyre,\n    front_right_tyre_off,\n    front_right_tyre_on,\n    screw_front_right_tyre,\n]\nfor i in range(len(fr_right) - 1):\n    ps.TaskPrecedence(task_before=fr_right[i], task_after=fr_right[i + 1])\n# rear left tyre operations\nre_left = [\n    unscrew_rear_left_tyre,\n    rear_left_tyre_off,\n    rear_left_tyre_on,\n    screw_rear_left_tyre,\n]\nfor i in range(len(re_left) - 1):\n    ps.TaskPrecedence(task_before=re_left[i], task_after=re_left[i + 1])\n# front left tyre operations\nre_right = [\n    unscrew_rear_right_tyre,\n    rear_right_tyre_off,\n    rear_right_tyre_on,\n    screw_rear_right_tyre,\n]\nfor i in range(len(re_right) - 1):\n    ps.TaskPrecedence(task_before=re_right[i], task_after=re_right[i + 1])\n\n# all un screw operations must start after the car is lift by both front and rear jacks\nfor unscrew_tasks in [\n    unscrew_front_left_tyre,\n    unscrew_front_right_tyre,\n    unscrew_rear_left_tyre,\n    unscrew_rear_right_tyre,\n]:\n    ps.TaskPrecedence(task_before=lift_rear_up, task_after=unscrew_tasks)\n    ps.TaskPrecedence(task_before=lift_front_up, task_after=unscrew_tasks)\n\n# lift down operations must occur after each screw task is completed\nfor screw_task in [\n    screw_front_left_tyre,\n    screw_front_right_tyre,\n    screw_rear_left_tyre,\n    screw_rear_right_tyre,\n]:\n    ps.TaskPrecedence(task_before=screw_task, task_after=lift_rear_down)\n    ps.TaskPrecedence(task_before=screw_task, task_after=lift_front_down)\n</code></pre>"},{"location":"use-case-formula-one-change-tires/#first-solution-plot-the-schedule","title":"First solution, plot the schedule","text":"<p><pre><code>solver = ps.SchedulingSolver(problem=change_tires_problem)\nsolution_1 = solver.solve()\nps.render_gantt_matplotlib(solution_1, fig_size=(10, 5), render_mode=\"Resource\")\n</code></pre> <pre><code>    Solver type:\n    ===========\n        -&gt; Standard SAT/SMT solver\n    Total computation time:\n    =====================\n        ChangeTires satisfiability checked in 0.14s\n</code></pre></p> <p></p>"},{"location":"use-case-formula-one-change-tires/#second-solution-add-a-makespan-objective","title":"Second solution: add a makespan objective","text":"<p>Obviously, the former solution is not the best solution, not sure Ferrari will win this race ! The whole \"change tires\" activity must be as short as possible, so let's add a makespan objective, i.e. a constraint that minimizes the schedule horizon.</p> <p><pre><code># add makespan objective\nps.ObjectiveMinimizeMakespan()\n\nsolver_2 = ps.SchedulingSolver(problem=change_tires_problem)\nsolution_2 = solver_2.solve()\nps.render_gantt_matplotlib(solution_2, fig_size=(9, 5), render_mode=\"Task\")\n</code></pre> <pre><code>    Solver type:\n    ===========\n        -&gt; Standard SAT/SMT solver\n    Incremental optimizer:\n    ======================\n        Found value: 26 elapsed time:0.112s\n        Checking better value &lt; 26\n        Found value: 20 elapsed time:0.211s\n        Checking better value &lt; 20\n        Found value: 19 elapsed time:0.259s\n        Checking better value &lt; 19\n        Found value: 18 elapsed time:0.265s\n        Checking better value &lt; 18\n        Found value: 17 elapsed time:0.272s\n        Checking better value &lt; 17\n        Found value: 16 elapsed time:0.278s\n        Checking better value &lt; 16\n        Found value: 15 elapsed time:0.295s\n        Checking better value &lt; 15\n        Found value: 14 elapsed time:0.318s\n        Checking better value &lt; 14\n        Found value: 13 elapsed time:0.380s\n        Checking better value &lt; 13\n        Found value: 12 elapsed time:0.388s\n        Checking better value &lt; 12\n        Can't find a better solution for problem ChangeTires.\n\n        Found optimum 12. Stopping iteration.\n        total number of iterations: 11\n        value: 12\n        ChangeTires satisfiability checked in 0.39s\n</code></pre></p> <p></p>"},{"location":"use-case-formula-one-change-tires/#third-solution-constraint-workers","title":"Third solution: constraint workers","text":"<p>This is not the best possible solution. Indeed, we can notice that the Gunner2 unscrews the RearRightTyre and screw the RearLeft tyre. We cannot imagine that a solution where gunners turn around the car is acceptable. There are two solutions to fix the schedule:</p> <ul> <li> <p>let the gunner be able to turn around the car, and add a \"Move\" task with a duration that represent the time necessary to move from one tyre to the other,</p> </li> <li> <p>constraint the worker to screw the same tyre he unscrewed. Let's go this way</p> </li> </ul> <p><pre><code>ps.SameWorkers(\n    select_workers_1=gunner_unscrew_front_left_tyre,\n    select_workers_2=gunner_screw_front_left_tyre,\n)\nps.SameWorkers(\n    select_workers_1=gunner_unscrew_front_right_tyre,\n    select_workers_2=gunner_screw_front_right_tyre,\n)\nps.SameWorkers(\n    select_workers_1=gunner_unscrew_rear_left_tyre,\n    select_workers_2=gunner_screw_rear_left_tyre,\n)\nps.SameWorkers(\n    select_workers_1=gunner_unscrew_rear_right_tyre,\n    select_workers_2=gunner_screw_rear_right_tyre,\n)\n\nsolver_3 = ps.SchedulingSolver(problem=change_tires_problem)\nsolution_3 = solver_3.solve()\nps.render_gantt_matplotlib(solution_3, fig_size=(9, 5), render_mode=\"Task\")\n</code></pre> <pre><code>Solver type:\n===========\n    -&gt; Standard SAT/SMT solver\nIncremental optimizer:\n======================\n    Found value: 20 elapsed time:0.096s\n    Checking better value &lt; 20\n    Found value: 19 elapsed time:0.196s\n    Checking better value &lt; 19\n    Found value: 18 elapsed time:0.218s\n    Checking better value &lt; 18\n    Found value: 17 elapsed time:0.225s\n    Checking better value &lt; 17\n    Found value: 16 elapsed time:0.231s\n    Checking better value &lt; 16\n    Found value: 15 elapsed time:0.249s\n    Checking better value &lt; 15\n    Found value: 14 elapsed time:0.254s\n    Checking better value &lt; 14\n    Found value: 13 elapsed time:0.316s\n    Checking better value &lt; 13\n    Found value: 12 elapsed time:0.321s\n    Checking better value &lt; 12\n    Can't find a better solution for problem ChangeTires.\n\n    Found optimum 12. Stopping iteration.\n    total number of iterations: 10\n    value: 12\n    ChangeTires satisfiability checked in 0.32s\n</code></pre></p> <p></p> <p>This is much better !</p>"},{"location":"use-case-software-development/","title":"Use case: software development","text":"<p>To illustrate the way to use ProcessScheduler, let's imagine the simple following use case: the developmenent of a scheduling software intended for end-user. The software is developed using Python, and provides a modern Qt GUI. Three junior developers are in charge (Elias, Louis, Elise), under the supervision of their project manager Justine. The objective of this document is to generate a schedule of the different developmenent tasks to go rom the early design stages to the first software release. This notebook can tested online at mybinder.org</p>"},{"location":"use-case-software-development/#step-1-import-the-module","title":"Step 1. Import the module","text":"<p>The best way to import the processscheduler module is to choose an alias import. Indeed, a global import should generate name conflicts. Here, the ps alias is used.</p> <pre><code>import processscheduler as ps\nfrom datetime import timedelta, datetime\n\n%config InlineBackend.figure_formats = ['svg']\n</code></pre>"},{"location":"use-case-software-development/#step-2-create-the-scheduling-problem","title":"Step 2. Create the scheduling problem","text":"<p>The SchedulingProblem has to be defined. The problem must have a name (it is a mandatory argument). Of course you can create as many problems (i.e; SchedulingProblem instances), for example if you need to compare two or more different schedules.</p> <pre><code>problem = ps.SchedulingProblem(\n    name=\"SoftwareDevelopment\", delta_time=timedelta(days=1), start_time=datetime.now()\n)\n</code></pre>"},{"location":"use-case-software-development/#step-3-create-tasks-instances","title":"Step 3. Create tasks instances","text":"<p>The SchedulingProblem has to be defined. The problem must have a name (it is a mandatory argument). Of course you can create as many problems (i.e SchedulingProblem instances) as needed, for example if you need to compare two or more different schedules. In this example, one period is one day.</p> <pre><code>preliminary_design = ps.FixedDurationTask(name=\"PreliminaryDesign\", duration=1)  # 1 day\ncore_development = ps.VariableDurationTask(name=\"CoreDevelopmenent\", work_amount=10)\ngui_development = ps.VariableDurationTask(name=\"GUIDevelopment\", work_amount=15)\nintegration = ps.VariableDurationTask(name=\"Integration\", work_amount=3)\ntests_development = ps.VariableDurationTask(name=\"TestDevelopment\", work_amount=8)\nrelease = ps.ZeroDurationTask(name=\"ReleaseMilestone\")\n</code></pre>"},{"location":"use-case-software-development/#step-4-create-tasks-time-constraints","title":"Step 4. Create tasks time constraints","text":"<p>Define precedences or set start and end times</p> <pre><code>ps.TaskStartAt(task=preliminary_design, value=0)\nps.TaskPrecedence(task_before=preliminary_design, task_after=core_development)\nps.TaskPrecedence(task_before=preliminary_design, task_after=gui_development)\nps.TaskPrecedence(task_before=gui_development, task_after=tests_development)\nps.TaskPrecedence(task_before=core_development, task_after=tests_development)\nps.TaskPrecedence(task_before=tests_development, task_after=integration)\nps.TaskPrecedence(task_before=integration, task_after=release)\n</code></pre> <pre><code>    TaskPrecedence_30566790(&lt;class 'processscheduler.task_constraint.TaskPrecedence'&gt;)\n    1 assertion(s):\n    Integration_end &lt;= ReleaseMilestone_start\n</code></pre>"},{"location":"use-case-software-development/#step-5-create-resources","title":"Step 5. Create resources","text":"<p>Define all resources required for all tasks to be processed, including productivity and cost_per_period.</p> <pre><code>elias = ps.Worker(\n    name=\"Elias\", productivity=2, cost=ps.ConstantCostFunction(value=600)\n)  # cost in $/day\nlouis = ps.Worker(\n    name=\"Louis\", productivity=2, cost=ps.ConstantCostFunction(value=600)\n)\nelise = ps.Worker(\n    name=\"Elise\", productivity=3, cost=ps.ConstantCostFunction(value=800)\n)\njustine = ps.Worker(\n    name=\"Justine\", productivity=2, cost=ps.ConstantCostFunction(value=1200)\n)\n</code></pre>"},{"location":"use-case-software-development/#step-6-assign-resources-to-tasks","title":"Step 6. Assign resources to tasks","text":"<pre><code>preliminary_design.add_required_resources([elias, louis, elise, justine])\ncore_development.add_required_resources([louis, elise])\ngui_development.add_required_resources([elise])\ntests_development.add_required_resources([elias, louis])\nintegration.add_required_resources([justine])\nrelease.add_required_resources([justine])\n</code></pre>"},{"location":"use-case-software-development/#step-7-add-a-total-cost-indicator","title":"Step 7. Add a total cost indicator","text":"<p>This resource cost indicator computes the total cost of selected resources.</p> <pre><code>cost_ind = ps.IndicatorResourceCost(list_of_resources=[elias, louis, elise, justine])\n</code></pre>"},{"location":"use-case-software-development/#step-8-solve-and-plot-using-plotly","title":"Step 8. Solve and plot using plotly","text":"<p><pre><code># solve\nsolver = ps.SchedulingSolver(problem=problem)\nsolution = solver.solve()\n</code></pre> <pre><code>    Solver type:\n    ===========\n        -&gt; Standard SAT/SMT solver\n    Total computation time:\n    =====================\n        SoftwareDevelopment satisfiability checked in 0.01s\n</code></pre></p> <pre><code>if solution:\n    ps.render_gantt_plotly(solution)\n</code></pre> <p></p>"},{"location":"workflow/","title":"Workflow","text":"<p>The structure of this documentation is designed to mirror the typical workflow of a ProcessScheduler Python script, guiding you through each step of the scheduling process:</p> <pre><code>graph TD\n  A[1. Create a SchedulingProblem] --&gt; B[2. Create objects that represent the problem];\n  B --&gt; C[3. Constraint the schedule];\n  C --&gt; D[4. Add indicators];\n  D --&gt; E[5. Add objectives];\n  E --&gt; F[6. Solve];\n  F --&gt; G[7. Analyse];\n  G --&gt; B;</code></pre> <ol> <li> <p>Create a SchedulingProblem: This is the foundational step where you establish the SchedulingProblem, serving as the primary container for all components of your scheduling scenario.</p> </li> <li> <p>Create Objects Representing The Problem: Select appropriate Task and Resource objects to accurately represent the elements of your use case. This step involves defining the tasks to be scheduled and the resources available for these tasks.</p> </li> <li> <p>Apply Constraints to the Schedule: Introduce temporal or logical constraints to define how tasks should be ordered or how resources are to be utilized. Constraints are critical for reflecting real-world limitations and requirements in your schedule.</p> </li> <li> <p>Add Indicators (optional): indicators or metrics are added to the scheduling problem. These indicators might include key performance metrics, resource utilization rates, or other measurable factors that are crucial for analyzing the effectiveness of the schedule. By adding this step, the schedule can be more effectively monitored and evaluated.</p> </li> <li> <p>Define Objectives (optional): you can specify one or more objectives. Objectives, built on Indicators, are used to determine what constitutes an 'optimal' schedule within the confines of your constraints. This could include minimizing total time, cost, or other metrics relevant to your scenario.</p> </li> <li> <p>Execute the Solver: Run the solver to find a feasible (and possibly optimal, depending on defined objectives) schedule based on your tasks, resources, constraints, and objectives.</p> </li> <li> <p>Analyze the Results: Once the solver has found a solution, you can render the schedule in various formats such as a Gantt chart or export it to Excel. This step is crucial for evaluating the effectiveness of the proposed schedule. Based on the analysis, you might revisit the representation stage to adjust your problem model, refine constraints, or alter objectives.</p> </li> </ol> <p>This workflow provides a structured approach to building and solving scheduling problems, ensuring that all essential aspects of your scheduling scenario are methodically addressed.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2023/11/30/first-blog-post/","title":"Major changes are on the way","text":"<p>The development of ProcessScheduler began in the fall of 2021. The past two years have laid the foundation for a free and open-source framework dedicated to planning and scheduling for industrial applications. The experience gained during this initial phase allows for medium-term projections.</p> <p>The current work is a complete overhaul of the code that aims to achieve the following objectives:</p>"},{"location":"blog/2023/11/30/first-blog-post/#improve-the-quality-and-robustness-of-the-code","title":"Improve the quality and robustness of the code","text":"<p>This involves expanding the test base, the code coverage. The pydantic library has been chosen to establish the definition of all classes.</p>"},{"location":"blog/2023/11/30/first-blog-post/#give-coherence-to-the-codebase","title":"Give coherence to the codebase","text":"<p>The project now needs a cleanup that ensures a consistency of the API, which has developed over time according to needs.</p>"},{"location":"blog/2023/11/30/first-blog-post/#increase-functional-coverage","title":"Increase functional coverage","text":"<p>To be able to model and simulate an increasing number of industrial situations and real use cases, new classes and functionalities must be added.</p>"},{"location":"blog/2023/11/30/first-blog-post/#rewrite-the-documentation","title":"Rewrite the documentation","text":"<p>The documentation hosted by the readthedocs service does not provide the required quality.</p>"},{"location":"blog/archive/2023/","title":"2023","text":""},{"location":"blog/category/general/","title":"General","text":""}]}